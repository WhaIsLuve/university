#Структуры_и_алгоритмы 
## Обход графа в ширину(Волновой обход графа)
Лабиринт состоит из множества комнат одинакового размера. Некоторые из комнат соединены дверьми. Определить можно ли пройти из комнаты А в комнату Б. И если да, то за какое минимальное количество перемещений. Математической моделью данной задачи является  не орграф. Ребра графа двери, а вершины комнаты. Проще всего задача решается обходом графа в ширину начиная с вершины А
### Алгоритм
1. Присваиваем вершине А метку 0
2. Всем вершинам смежным с вершиной А присваивается метка 1
3. Процесс продолжается следующим образом: всем не помеченным вершинам смежным с 1 присваивается 2, далее 3 и т.д.
4. Если помечена вершина Б, то алгоритм завершается, метка вершины Б и есть минимальное кол-во шагов от А до Б
5. Если на некотором шаге ни одна вершина не получила новую метку, а вершина Б так и не помечена, то пути из вершины А до вершины Б не существует.
Если необходимо найти не только кол-во шагов, но еще и путь, то будем двигаться от вершины Б к одной смежных вершин с меткой на 1 меньше данной вершины.
```java
public int makeWave(int a, int b) {
	int path[] = new int[size+1];
	for (int i = 1; i <= size; i++) path[i] = -1;
	path[a] = 0;
	int num = 1; i = 1;
	boolean f = false; f1 = true;
	do {
		while(i <= size && path[i] != num-1) i++;
		if (i <= size) {
			f = true;
			for(int j = 1; j <= size; j++) {
				if(gr[i][j] == 1 && path[j] == -1) {
					path[j] = num;
				}
				i++;
			}
		}
		else {
			if(f) {
				f = false;
				num++;
			}
			else {
				f1 = false;
			}
		}
	} while(f1);
	return path[b];
}
```
Обход в ширину фактически позволяет найти путь минимальной длинны от вершины А к любой другой вершине в произвольном, но не в взвешенном графе пути. Если ребра графа имеют стоимость, то обход в ширину данную задачу не решает.
## Алгоритм Дейкстры
Имеется произвольный граф к каждому ребру, которого присвоена некоторая неотрицательная стоимость. Путь минимальной стоимости требуется найти из вершины А в вершину Б. 
1. Присвоим вершине А метку 0 объявив метку постоянной. Остальным вершинам присвоим метку +inf, считая эти метки временными.
2. Берем вершину, получившую постоянную метку на предыдущем шаге и для каждой смежной с ней вершиной G пересчитываем временную метку по формуле `metka[j] = min(metka[j], metka[i] + gr[i][j])`.
3. Из всех временных меток выбираем минимальную делаем ее постоянной и если это не метка вершины Б, то идем на пункт 2, иначе пункт 4.
4. Постоянная метка вершины Б и есть стоимость искомого минимального пути
5. Сам путь можно найти двумя способами:
	1. Пойти обратно
Реализацию смотри в беседе