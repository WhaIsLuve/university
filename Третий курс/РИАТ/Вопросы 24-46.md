### 24. Нисходящий и восходящий подход к разработке программного обеспечения, средства описания структурных алгоритмов: базовые и дополнительные алгоритмические структуры, псевдокоды, Flow-формы, диаграммы Насси-Шнейдермана

Разберем этот билет простым языком, опираясь только на учебник Г.С. Ивановой «Технология программирования» (2002).

#### Нисходящий и восходящий подход к разработке программного обеспечения

1. **Нисходящий подход**  
   Это когда программу начинают разрабатывать с общей идеи и постепенно детализируют. В учебнике (стр. 10–11) это называется проектированием «сверху вниз». Сначала создают общую структуру программы, определяют, как она будет работать в целом, а потом разбивают на мелкие части – подпрограммы или модули. Это помогает заранее продумать, как все части программы будут взаимодействовать. Например, сначала проектируют интерфейс, а потом пишут код для каждой функции. Такой подход хорош, потому что снижает количество ошибок, так как интерфейсы модулей продуманы заранее. В книге говорится, что нисходящий подход стал основой структурного программирования, появившегося в 60–70-х годах, чтобы справиться с «кризисом программирования» (стр. 10).

2. **Восходящий подход**  
   Это когда начинают с маленьких, простых частей (подпрограмм), а потом собирают их в большую программу. Учебник (стр. 10) объясняет, что такой подход использовался в ранние годы программирования, но часто приводил к проблемам. Например, подпрограммы писали отдельно, а при сборке оказывалось, что они плохо стыкуются, и приходилось всё переделывать. Это увеличивало количество ошибок, и тестирование занимало до 80% времени разработки. Поэтому восходящий подход сейчас используют реже, но он может быть полезен, если нужно быстро написать и протестировать отдельные модули.

#### Средства описания структурных алгоритмов

Структурные алгоритмы – это способ писать программы так, чтобы код был понятным и без запутанных переходов. Учебник (стр. 11) упоминает, что структурное программирование ограничивает конструкции алгоритмов, чтобы их было проще читать и проверять. Для описания таких алгоритмов используют разные средства.

1. **Базовые алгоритмические структуры**  
   В книге (стр. 11) сказано, что структурное программирование опирается на три основные конструкции:  
   - **Последовательность**: команды выполняются одна за другой, без ветвлений.  
   - **Выбор (ветвление)**: программа выбирает, что делать, в зависимости от условия (например, if-then-else).  
   - **Цикл**: повторение команд, пока выполняется условие (например, while или for).  
   Эти структуры простые, понятные и позволяют избежать «спагетти-кода» (запутанных переходов, как в старых программах).

2. **Дополнительные алгоритмические структуры**  
   Учебник не углубляется в дополнительные структуры, но упоминает (стр. 11), что в языках программирования, таких как Pascal или C, добавлены вложенные подпрограммы, локализация данных и ограничение их видимости. Это помогает делать алгоритмы более организованными. Например, можно создавать подпрограммы внутри других подпрограмм или ограничивать доступ к данным, чтобы они не менялись случайно.

3. **Псевдокоды**  
   Псевдокод – это способ описать алгоритм простым языком, похожим на обычную речь, но с элементами программирования. В учебнике (стр. 11) сказано, что псевдокоды используются для формального описания алгоритмов при структурном подходе. Это как черновик программы: пишешь, что она должна делать, без привязки к конкретному языку программирования. Например:  
   ```
   Если x > 0, то вывести "Положительное число", иначе вывести "Отрицательное или ноль".
   ```  
   Псевдокод помогает понять логику программы до написания настоящего кода.

4. **Flow-формы (схемы алгоритмов)**  
   Flow-формы – это схемы, которые показывают, как данные и управление движутся в программе. В книге (стр. 4, 11) упоминаются схемы алгоритмов, которые должны соответствовать стандартам ЕСПД (Единая система программной документации). Это графики с блоками (прямоугольники, ромбы и т.д.), где прямоугольники – это действия, ромбы – условия, а стрелки показывают порядок выполнения. Например, схема для проверки числа может выглядеть так: ромб с вопросом «x > 0?» и две стрелки – одна к блоку «Вывести положительное», другая к «Вывести отрицательное». Такие схемы помогают визуально понять алгоритм.

5. **Диаграммы Насси-Шнейдермана**  
   Это другой способ рисовать алгоритмы, чтобы они были понятными. Учебник (стр. 11) называет их одним из средств описания структурных алгоритмов. В отличие от Flow-форм, диаграммы Насси-Шнейдермана используют прямоугольники, разделенные на части, чтобы показать последовательность, выбор или цикл. Например, для цикла рисуют прямоугольник, где верхняя часть – условие цикла, а нижняя – действия внутри цикла. Они проще для чтения, чем обычные блок-схемы, потому что меньше стрелок и всё организовано в одном блоке.

#### Итог
Нисходящий подход (от общего к частному) лучше для сложных программ, потому что помогает продумать структуру заранее. Восходящий (от частей к целому) может быть проще для маленьких задач, но чаще приводит к ошибкам. Для описания алгоритмов используют базовые структуры (последовательность, выбор, цикл), псевдокоды, Flow-формы и диаграммы Насси-Шнейдермана. Эти инструменты делают алгоритмы понятными и помогают избежать путаницы в коде.

---
### 25. Программирование с защитой от ошибок: проверка выполнения операций, контроль промежуточных результатов, снижение погрешностей результатов, обработка исключений; сквозной структурный контроль

#### Программирование с защитой от ошибок

Программирование с защитой от ошибок – это подход, чтобы программа работала надежно и не ломалась при сбоях. В учебнике (стр. 4, раздел 2.7) описаны способы, которые помогают этого добиться.

1. **Проверка выполнения операций**  
   Программа должна проверять, правильно ли выполняются команды. Например, если пользователь вводит данные, программа убеждается, что они подходят. В книге (стр. 226) советуют проверять данные сразу после ввода. Если ждут число, а ввели буквы, программа должна выдать сообщение об ошибке, а не продолжать с неверными данными.

2. **Контроль промежуточных результатов**  
   Чтобы найти ошибку早く, нужно проверять результаты на важных этапах. Учебник (стр. 226) рекомендует выводить данные в ключевых точках алгоритма, например, перед ветвлением или вызовом подпрограммы. Это как проверять, правильно ли посчиталась сумма, прежде чем использовать её дальше.

3. **Снижение погрешностей результатов**  
   Погрешности возникают, когда вычисления неточны, например, из-за дробных чисел. В книге (стр. 227) сказано, что такие ошибки легко найти, так как они проявляются в конкретном месте. Для их снижения используют числа с большей точностью (например, double вместо float) или проверяют, чтобы результаты не выходили за допустимые пределы.

4. **Обработка исключений**  
   Исключения – это неожиданные ситуации, вроде деления на ноль или попытки открыть несуществующий файл. Учебник (стр. 226) не детализирует механизмы вроде try-catch, но подчеркивает, что программа должна быть готова к сбоям. Например, проверять, не равен ли делитель нулю, или выдавать сообщение, если файл не найден, чтобы программа не «зависла».

#### Сквозной структурный контроль

Сквозной структурный контроль – это способ следить за работой программы на всех этапах, используя структурированный подход. В учебнике (стр. 4, раздел 2.8) сказано, что это часть структурного программирования, где программу делят на простые блоки (последовательность, выбор, цикл) для удобной проверки.

- Программа разбивается на небольшие куски (модули или подпрограммы до 40–50 строк, стр. 11). Каждый кусок тестируют отдельно, а потом проверяют их совместную работу. Это помогает быстро найти, где ошибка.
- Учебник (стр. 226) советует наращивать программу «сверху вниз» – от общей структуры к деталям, тестируя каждый шаг. Выводить данные в ключевых точках, чтобы видеть, что происходит. Также важно проверять места, где уже находили ошибки, так как там они чаще повторяются.

#### Итог

Программирование с защитой от ошибок делает программу надежной: проверяют команды, следят за промежуточными результатами, минимизируют погрешности и готовятся к сбоям. Сквозной структурный контроль помогает проверять программу по частям на каждом этапе, чтобы легче находить и исправлять ошибки.

---
### 26. Разработка и анализ требований к программному обеспечению: определение целей проектируемого программного обеспечения, определение целей управления проектом; техническое задание и специ ЧИТАТЬ ДАЛЕЕ

#### Разработка и анализ требований к программному обеспечению

Разработка и анализ требований – это первый шаг в создании программы, когда решают, что она должна делать и как. Учебник Г.С. Ивановой (стр. 4, глава 3) объясняет, что это включает определение целей, составление технического задания и выделение требований.

1. **Определение целей проектируемого программного обеспечения**  
   Цели программы – это ответ на вопрос, зачем она нужна и какие задачи решает. В книге (стр. 7, 229) сказано, что нужно четко описать назначение программы и область её применения. Например, программа может быть для учета товаров в магазине или управления роботом. Цели определяют в начале, чтобы понять, что именно разрабатывать. Это помогает разработчикам и заказчикам говорить на одном языке.

2. **Определение целей управления проектом**  
   Управление проектом – это про то, как организовать работу, чтобы программа была готова вовремя и с нужным качеством. Учебник (стр. 16) упоминает, что сложность разработки растет из-за коллективной работы и больших объемов кода. Цели управления включают:  
   - Составить план разработки (сроки, этапы).  
   - Распределить задачи между программистами.  
   - Контролировать качество (тестирование, отладка).  
   Например, в книге (стр. 7) говорится, что проект должен начинаться с технического задания и заканчиваться документацией, чтобы всё было четко организовано.

3. **Техническое задание и спецификации программного обеспечения**  
   - **Техническое задание (ТЗ)**: Это документ, где описано, что должна делать программа, какие у неё требования и как её будут проверять. В учебнике (стр. 4, раздел 3.4) сказано, что ТЗ разрабатывают на основе предпроектных исследований (анализа задачи и области применения). ТЗ включает:  
     - Назначение программы.  
     - Какие функции она должна выполнять.  
     - Условия использования (например, на каком компьютере).  
     - Требования к надежности и скорости.  
   - **Спецификации программного обеспечения**: Это более детальное описание, как программа будет работать. В книге (стр. 4, глава 4) объясняется, что при структурном подходе спецификации включают диаграммы (потоков данных, переходов состояний) и описание алгоритмов. Например, спецификация может показать, как данные движутся от ввода к выводу результата.

4. **Функциональные и нефункциональные требования**  
   - **Функциональные требования**: Это то, что программа должна уметь делать. Например, в учебнике (стр. 4, раздел 3.1) говорится о классификации программ по функциям: вычислительные, управляющие, информационные. Если это программа для магазина, функциональные требования – это учет товаров, расчет скидок, печать чеков.  
   - **Нефункциональные требования**: Это про качество программы, а не её функции. В книге (стр. 4, раздел 3.2) упоминаются эксплуатационные требования, такие как:  
     - Скорость работы (программа не должна тормозить).  
     - Надежность (не должна ломаться).  
     - Удобство использования (понятный интерфейс).  
     - Совместимость с оборудованием или другими программами.  
   Например, программа должна работать на Windows и не использовать больше 512 МБ памяти.

#### Итог

Разработка и анализ требований – это основа для создания программы. Сначала определяют, зачем нужна программа (цели) и как организовать работу (управление проектом). Потом составляют техническое задание, где прописывают, что программа должна делать, и спецификации, где детализируют, как это будет реализовано. Требования делят на функциональные (что делает программа) и нефункциональные (как хорошо она это делает). Всё это помогает сделать программу, которая решает задачу и работает надежно.

---
### 27. Технологические требования: выбор архитектуры ПО, выбор типа пользовательского интерфейса, выбор подхода к разработке, выбор языка и среды программирования

#### Технологические требования

Технологические требования определяют, как будет устроена программа, как она будет взаимодействовать с пользователем и какие инструменты использовать для её создания. Учебник Г.С. Ивановой (стр. 4, глава 3, раздел 3.5) объясняет, что эти решения принимают на начальном этапе проектирования, чтобы программа была эффективной и удобной.

1. **Выбор архитектуры ПО**  
   Архитектура ПО – это то, как программа организована внутри, как её части связаны между собой. В учебнике (стр. 9–14) описаны разные варианты:  
   - **Ранние программы** (стр. 9) состояли из кода и глобальных данных, но это приводило к ошибкам, если данные случайно менялись.  
   - **Модульная архитектура** (стр. 11) делит программу на модули (например, модуль для графики или печати), которые работают через четкие интерфейсы. Это упрощает работу нескольких программистов.  
   - **Объектная архитектура** (стр. 12) строит программу из объектов, которые объединяют данные и функции. Это удобно для сложных программ, так как объекты можно использовать повторно.  
   - **Компонентная архитектура** (стр. 13–14) использует готовые компоненты (например, COM или CORBA), которые собирают как конструктор. Это подходит для больших программ, где части работают на разных компьютерах.  
   Выбор зависит от задачи: для простой программы хватит модулей, а для сложной системы лучше объектная или компонентная архитектура.

2. **Выбор типа пользовательского интерфейса**  
   Пользовательский интерфейс – это то, как человек взаимодействует с программой. В учебнике (стр. 5, глава 8) описаны разные типы интерфейсов:  
   - **Текстовый интерфейс**: пользователь вводит команды в консоли (например, в старых системах MS DOS).  
   - **Графический интерфейс** (стр. 5, раздел 8.5): окна, кнопки, меню, как в современных программах. Это удобно для большинства пользователей.  
   - **Интерфейс прямого манипулирования** (стр. 5, раздел 8.7): пользователь взаимодействует с объектами, например, перетаскивает файлы мышкой.  
   - **Интеллектуальный интерфейс** (стр. 5, раздел 8.8): программа сама подсказывает, что делать, или адаптируется под пользователя.  
   Выбор зависит от задачи и пользователя. Например, для обычных пользователей лучше графический интерфейс, а для сложных задач – прямое манипулирование.

3. **Выбор подхода к разработке**  
   Подход к разработке – это как будут создавать программу. Учебник (стр. 4, 10–13) выделяет несколько подходов:  
   - **Структурный подход** (стр. 10–11): программу разбивают на небольшие подпрограммы (до 40–50 строк), проектируют сверху вниз, от общей структуры к деталям. Подходит для программ среднего размера.  
   - **Объектный подход** (стр. 12): программа строится из объектов, которые объединяют данные и функции. Это удобно для сложных систем, так как код можно использовать повторно.  
   - **Компонентный подход** (стр. 13): используют готовые компоненты, которые собирают в программу. Подходит для больших проектов, где нужна совместимость с другими системами.  
   Выбор зависит от сложности программы и команды. Например, для большого проекта с несколькими программистами лучше компонентный подход.

4. **Выбор языка и среды программирования**  
   Язык и среда программирования – это инструменты, которыми пишут код. В книге (стр. 7, 11–12) упомянуты разные варианты:  
   - **Языки**:  
     - **Структурные языки** (Pascal, C, стр. 11) хороши для простых и средних программ, так как поддерживают модули и локальные данные.  
     - **Объектно-ориентированные языки** (C++, Java, стр. 12) подходят для сложных систем, где нужна работа с объектами и наследованием.  
     - **Ассемблер** (стр. 9) используется для низкоуровневых задач, но сложен и редко применяется для больших программ.  
   - **Среды программирования**:  
     - Визуальные среды, такие как Delphi или Visual C++ (стр. 12), позволяют быстро создавать интерфейсы и использовать готовые компоненты.  
     - CASE-технологии (стр. 16) помогают автоматизировать проектирование, например, для построения диаграмм UML.  
   Выбор зависит от задачи и опыта команды. Например, для быстрого создания интерфейса лучше взять Delphi, а для сложной системы – C++ или Java.

#### Итог

Технологические требования – это решения о том, как устроить программу, как пользователь будет с ней работать и какие инструменты использовать. Архитектура может быть модульной, объектной или компонентной в зависимости от сложности. Интерфейс выбирают по типу пользователей: графический для простоты, прямое манипулирование для сложных задач. Подход к разработке (структурный, объектный, компонентный) зависит от размера проекта, а язык и среда – от задачи и удобства команды. Правильный выбор делает программу удобной и надежной.

---
### 28. Планирование процесса проектирования, виды планов: календарный, индивидуальный, сетевой график разработки и проектирования программного обеспечения

#### Планирование процесса проектирования

Планирование процесса проектирования – это организация работы над созданием программы, чтобы всё было сделано вовремя и качественно. Учебник Г.С. Ивановой (стр. 7, 16) подчеркивает, что сложность разработки программ требует четкого плана, особенно при коллективной работе. Планирование включает определение этапов, сроков и распределение задач между разработчиками. В книге (стр. 4, раздел 1.4) описаны этапы жизненного цикла программы: анализ требований, проектирование, реализация, тестирование, отладка и документирование. Планирование помогает связать эти этапы в единый процесс.

#### Виды планов

Учебник прямо не описывает календарный, индивидуальный и сетевой график, но из контекста (стр. 4, 7, 16) можно вывести, как эти планы применяются к разработке программного обеспечения.

1. **Календарный план**  
   Это расписание, в котором указаны сроки выполнения этапов разработки. В книге (стр. 7) говорится, что проект начинается с технического задания, где определяют, сколько времени нужно на каждый этап: анализ, проектирование, написание кода, тестирование и создание документации. Календарный план отвечает на вопрос: «Когда что делаем?». Например, можно запланировать двеස

System: 2 недели на анализ требований, 3 недели на проектирование, 4 недели на кодирование, 2 недели на тестирование и 1 неделю на документацию. Это помогает команде держаться в сроках и заказчику понимать, когда ждать результат.

2. **Индивидуальный план**  
   Это план задач для каждого разработчика. Учебник (стр. 16) упоминает, что при коллективной разработке задачи распределяют между программистами. Индивидуальный план определяет, кто за что отвечает. Например, один программист пишет модуль для интерфейса, другой – для обработки данных, третий – для тестирования. В книге (стр. 11–12) подчеркивается, что модульное и объектное программирование позволяют разделять задачи, и индивидуальный план помогает каждому знать, что и когда ему делать.

3. **Сетевой график разработки и проектирования программного обеспечения**  
   Сетевой график – это схема, которая показывает, какие этапы разработки зависят друг от друга и в каком порядке их выполнять. Хотя учебник (стр. 4, раздел 1.4) не называет это «сетевым графиком», он описывает жизненный цикл программы, где этапы связаны: нельзя начать кодирование без анализа требований, а тестирование – без готового кода. Сетевой график выглядит как диаграмма, где стрелки показывают порядок задач и их зависимости. Например, стрелка от «анализ требований» к «проектирование» показывает, что второе начинается после первого. Это помогает увидеть, какие задачи можно делать параллельно, а какие – только после других.

#### Итог

Планирование проектирования программ – это организация работы, чтобы всё было сделано вовремя. Календарный план задает сроки для этапов, индивидуальный – распределяет задачи между разработчиками, а сетевой график показывает, как этапы связаны и в каком порядке их выполнять. Эти планы помогают команде работать слаженно и избежать задержек или ошибок.

---

### 29. Структурный подход к проектированию программного обеспечения: основные принципы, лежащие в основе структурного подхода, средства описания функциональной структуры, средства описания отношения между данными, применение средств на стадиях жизненного цикла программного обеспечения

#### Структурный подход к проектированию программного обеспечения

Структурный подход – это метод разработки программ, при котором сложная задача разбивается на простые части для упрощения проектирования, написания и проверки кода. В учебнике Г.С. Ивановой (стр. 10–11, главы 4 и 5) указано, что он появился в 60–70-х годах для решения «кризиса программирования», когда сложные программы часто задерживались из-за ошибок.

#### Основные принципы структурного подхода

В учебнике (стр. 11) описаны основные принципы:  
- **Декомпозиция**: Задачу делят на небольшие подпрограммы (до 40–50 строк кода), которые легче разрабатывать и тестировать.  
- **Проектирование сверху вниз**: Сначала создают общую структуру программы, затем детализируют её части, чтобы заранее продумать их взаимодействие.  
- **Ограничение конструкций алгоритмов**: Используют три базовые структуры: последовательность, выбор (if-then-else) и цикл (while, for). Это делает код понятным и исключает запутанные переходы.  
- **Формальные модели**: Применяют диаграммы и другие инструменты для четкого описания программы.  

Эти принципы поддерживаются языками, такими как Pascal и C, которые позволяют создавать подпрограммы, локализовать данные и ограничивать их видимость (стр. 11).

#### Средства описания функциональной структуры

Функциональная структура показывает, как программа выполняет задачи. Учебник (стр. 4, глава 4) выделяет следующие инструменты:  
- **Диаграммы переходов состояний** (раздел 4.2): Отображают переходы программы между состояниями, например, от меню к обработке данных.  
- **Функциональные диаграммы** (раздел 4.3): Показывают функции программы и их связи, представляя собой карту её возможностей.  
- **Диаграммы потоков данных** (раздел 4.4): Иллюстрируют движение данных от ввода через обработку к выводу, например, от пользовательского ввода к расчету и отчету.  
- **Структурные карты Константайна** (стр. 5, раздел 5.3): Схемы, отображающие иерархию функций, показывая, как главная функция делится на подфункции.  

Эти средства помогают на этапах анализа и проектирования понять, что должна делать программа и как её части связаны.

#### Средства описания отношения между данными

Отношения между данными определяют их организацию и связи. Учебник (стр. 4, раздел 4.5) описывает:  
- **Структуры данных**: Способы хранения данных, такие как массивы, списки или деревья, проектируемые для удобной обработки (стр. 5, раздел 5.4).  
- **Диаграммы отношений компонентов данных**: Показывают связи данных, например, как запись о клиенте (имя, адрес, телефон) связана с данными о заказах.  
- **Математические модели** (раздел 4.6): Используются для сложных задач, чтобы описать обработку данных, например, уравнения для расчета траектории.  

Эти инструменты помогают выбрать оптимальные структуры данных для быстрой и безошибочной работы программы.

#### Применение средств на стадиях жизненного цикла программного обеспечения

Жизненный цикл программы включает этапы: анализ требований, проектирование, реализация, тестирование, отладка и документирование (стр. 4, раздел 1.4). Учебник (стр. 4–5, главы 4 и 5) объясняет их использование:  
- **Анализ требований** (глава 4): Диаграммы переходов состояний, функциональные диаграммы и потоки данных помогают определить, что должна делать программа, и составить спецификации (раздел 4.1).  
- **Проектирование** (глава 5): Структурные карты Константайна и метод пошаговой детализации (раздел 5.2) разбивают программу на подпрограммы. Проектирование структур данных и декомпозиция данных (разделы 5.4, 5.5) организуют данные. CASE-технологии (раздел 5.6) автоматизируют создание диаграмм.  
- **Реализация**: Код пишут на основе диаграмм и структур данных. Структурный подход обеспечивает простые модули, удобные для кодирования и проверки (стр. 11).  
- **Тестирование и отладка**: Диаграммы, например потоки данных, помогают найти ошибки, показывая, где данные могут обрабатываться неверно (глава 9).  
- **Документирование**: Диаграммы и описания включают в пояснительную записку (стр. 229), чтобы объяснить устройство и работу программы.

#### Итог

Структурный подход упрощает разработку, разбивая задачу на части, проектируя их сверху вниз и используя простые конструкции. Диаграммы переходов состояний, функциональные диаграммы, потоки данных и карты Константайна описывают функции программы, а структуры данных и их диаграммы – организацию данных. Эти средства применяются на всех этапах жизненного цикла, обеспечивая понятность, надежность и удобство поддержки программы.

---
### 30. Спецификации ПО при структурном подходе: формальные модели, зависящие от подхода к разработке и не зависящие от подхода – диаграммы переходов состояний, математические модели предметной области

#### Спецификации ПО при структурном подходе

Спецификации программного обеспечения (ПО) при структурном подходе – это документы и модели, которые описывают, что должна делать программа, как она устроена и как будет работать. Учебник Г.С. Ивановой (стр. 4, глава 4, раздел 4.1) объясняет, что спецификации создаются на этапе анализа требований, чтобы детализировать задачу и подготовить основу для проектирования. Они включают формальные модели, которые делятся на зависящие от подхода к разработке (специфичные для структурного подхода) и не зависящие от подхода (универсальные).

#### Формальные модели, зависящие от подхода к разработке

Структурный подход основан на декомпозиции задачи на подпрограммы, проектировании сверху вниз и использовании простых алгоритмических конструкций (стр. 10–11). Формальные модели, зависящие от этого подхода, отражают его принципы. Учебник (стр. 4, разделы 4.3–4.5) выделяет следующие:  
- **Функциональные диаграммы** (раздел 4.3): Показывают, какие функции выполняет программа и как они связаны. Это иерархическая схема, где главная функция разбивается на подфункции, что соответствует принципу декомпозиции. Например, для программы учета товаров это может быть функция «Обработка заказа», разделенная на «Ввод данных», «Расчет» и «Вывод отчета».  
- **Диаграммы потоков данных** (раздел 4.4): Описывают, как данные движутся через программу – от ввода через обработку к выводу. Они показывают модули программы и потоки данных между ними, что помогает спроектировать подпрограммы и их интерфейсы. Например, данные о заказе поступают в модуль расчета, а затем в модуль печати.  
- **Структурные карты Константайна** (стр. 5, раздел 5.3): Отображают иерархию функций в виде дерева, где каждая подпрограмма представлена блоком. Это средство уточняет функциональную структуру, используемую при проектировании сверху вниз.  

Эти модели зависят от структурного подхода, так как ориентированы на процедурную декомпозицию и модульную организацию программы.

#### Формальные модели, не зависящие от подхода к разработке

Некоторые модели универсальны и применяются независимо от подхода (структурного, объектного или другого). Учебник (стр. 4, разделы 4.2, 4.6) описывает два таких средства:  
- **Диаграммы переходов состояний** (раздел 4.2): Показывают, как программа переходит из одного состояния в другое в зависимости от событий или условий. Например, в интерфейсе это может быть переход от «Главное меню» к «Обработка данных» при нажатии кнопки. Эти диаграммы универсальны, так как описывают поведение системы в любой методологии. Они помогают понять логику работы программы, особенно для систем с четкими состояниями, например, в управлении устройствами.  
- **Математические модели предметной области** (раздел 4.6): Это формальные описания задачи с использованием математики, например, уравнений или формул. Они не привязаны к подходу, так как описывают суть задачи, а не способ её реализации. Например, для программы расчета траектории ракеты математическая модель может включать уравнения движения, которые одинаково применимы в структурном или объектном подходе.  

Эти модели используются для анализа требований и создания спецификаций, так как дают общее представление о задаче, не зависящее от метода разработки.

#### Применение моделей в спецификациях

В учебнике (стр. 4, раздел 4.1) указано, что спецификации при структурном подходе создаются на основе анализа требований и включают:  
- **Описание функций**: Функциональные диаграммы и структурные карты Константайна уточняют, какие задачи решает программа и как они разбиваются на подзадачи.  
- **Потоки данных**: Диаграммы потоков данных показывают, как информация передается между модулями, что важно для проектирования интерфейсов подпрограмм.  
- **Поведение системы**: Диаграммы переходов состояний описывают, как программа реагирует на события, что помогает специфицировать динамику работы.  
- **Математическая основа**: Математические модели предметной области задают формальные правила обработки данных, например, алгоритмы вычислений.  

Эти модели применяются на этапе анализа требований (глава 4) для создания четких спецификаций, которые затем используются на этапе проектирования (глава 5). Например, диаграммы потоков данных помогают разбить программу на модули, а диаграммы переходов состояний – спроектировать логику интерфейса.

#### Итог

Спецификации ПО при структурном подходе включают формальные модели, которые делятся на зависящие и не зависящие от подхода. Зависящие модели – функциональные диаграммы, диаграммы потоков данных и структурные карты Константайна – отражают декомпозицию и модульность структурного подхода. Независящие модели – диаграммы переходов состояний и математические модели предметной области – универсальны и описывают поведение системы и задачу в целом. Эти средства помогают создать четкие спецификации, которые служат основой для проектирования, реализации и тестирования программы.

---

### 31. Метод функционального моделирования SADT: функциональная модель SADT, стандарт IDEF0; синтаксис и семантика моделей IDEF0: действия-функции; стрелки входа, управления, выхода, механизма исполнения; комбинированные стрелки, разбиение и соединение стрелок; туннели

#### Метод функционального моделирования SADT

Метод SADT (Structured Analysis and Design Technique) – это методология функционального моделирования, используемая для анализа и проектирования сложных систем, включая программное обеспечение. Учебник Г.С. Ивановой (стр. 4, раздел 4.4; стр. 5, раздел 5.6) упоминает SADT как инструмент структурного подхода, который помогает описывать функции системы и потоки данных. SADT включает стандарт IDEF0, который формализует построение функциональных моделей.

#### Функциональная модель SADT и стандарт IDEF0

Функциональная модель SADT представляет систему как набор функций (действий), связанных потоками данных и управления. В учебнике (стр. 4, раздел 4.4) подчеркивается, что SADT позволяет разбить сложную задачу на простые части, описывая, что система делает, какие данные использует и как взаимодействует с внешней средой.

**Стандарт IDEF0** – это формализованная версия SADT, разработанная для создания четких и однозначных моделей. Согласно учебнику (стр. 5, раздел 5.6), IDEF0 используется в CASE-технологиях для анализа и проектирования систем. Модель IDEF0 состоит из диаграмм, где каждая диаграмма описывает функции системы и их взаимосвязи. Основные черты:  
- **Иерархичность**: Система разбивается на уровни – от общей функции (A-0) до детальных подфункций (A1, A2 и т.д.).  
- **Четкость**: Стандарт определяет строгие правила построения диаграмм, чтобы избежать двусмысленности.  
- **Функциональность**: Фокус на том, что делает система, а не как (реализация откладывается на позже).

#### Синтаксис и семантика моделей IDEF0

Модели IDEF0 строятся из блоков (действий-функций) и стрелок, которые описывают потоки данных и управления. Учебник не детализирует IDEF0, но ссылается на диаграммы потоков данных (стр. 4, раздел 4.4), которые близки по концепции. Ниже описаны элементы IDEF0, основанные на стандарте и контексте учебника.

1. **Действия-функции**  
   - **Определение**: Блок, представляющий функцию или процесс, выполняемый системой. В IDEF0 это прямоугольник с названием функции (глагол + существительное, например, «Обработать заказ»).  
   - **Семантика**: Описывает, что делает система или её часть. Каждая функция преобразует входные данные в выходные под влиянием управления и с использованием механизмов.  
   - **В учебнике**: Упоминаются как часть функциональных диаграмм (стр. 4, раздел 4.3), где функции разбиваются на подфункции, что соответствует декомпозиции в IDEF0.

2. **Стрелки входа, управления, выхода, механизма исполнения**  
   - **Стрелки входа (Input)**: Данные или объекты, которые функция преобразует. Входят в левую сторону блока. Например, «Данные о заказе» для функции «Обработать заказ».  
   - **Стрелки управления (Control)**: Условия или правила, которые управляют выполнением функции. Входят в верхнюю сторону блока. Например, «Правила обработки» или «Команда пользователя».  
   - **Стрелки выхода (Output)**: Результаты, которые производит функция. Выходят из правой стороны блока. Например, «Обработанный заказ» или «Отчет».  
   - **Стрелки механизма исполнения (Mechanism)**: Ресурсы или средства, выполняющие функцию. Входят в нижнюю сторону блока. Например, «Программа», «Компьютер» или «Оператор».  
   - **В учебнике**: Эти стрелки соответствуют потокам данных в диаграммах потоков данных (стр. 4, раздел 4.4), где данные движутся между модулями, а управление задается условиями.

3. **Комбинированные стрелки, разбиение и соединение стрелок**  
   - **Комбинированные стрелки**: Одна стрелка может представлять несколько потоков данных или управления, если они логически связаны. Например, «Данные клиента» может включать имя, адрес и телефон.  
   - **Разбиение стрелок**: Комбинированная стрелка может разделяться на несколько стрелок, чтобы показать отдельные компоненты данных. Например, «Данные клиента» разбивается на «Имя» и «Адрес» для разных функций.  
   - **Соединение стрелок**: Несколько стрелок могут объединяться в одну, если данные собираются в единый поток. Например, «Имя» и «Адрес» соединяются в «Данные клиента».  
   - **Семантика**: Разбиение и соединение отражают детализацию или агрегацию данных на разных уровнях модели.  
   - **В учебнике**: Упоминается в контексте декомпозиции данных (стр. 5, раздел 5.5), где сложные данные разбиваются на простые компоненты.

4. **Туннели**  
   - **Определение**: Специальная нотация в IDEF0, обозначающая, что стрелка «исчезает» или «появляется» на диаграмме, чтобы избежать перегрузки. Туннель маркируется круглыми скобками вокруг стрелки.  
   - **Семантика**: Используется для упрощения диаграмм, когда данные передаются на другой уровень или диаграмму без явного отображения. Например, вход «Данные о заказе» может быть туннелирован, если он идет из внешней системы.  
   - **Пример**: Если на диаграмме A1 данные поступают из внешнего источника, стрелка маркируется как туннель, чтобы не рисовать её связь с родительской диаграммой A0.  
   - **В учебнике**: Не упоминаются напрямую, но связаны с упрощением диаграмм потоков данных (стр. 4, раздел 4.4), где сложные потоки могут быть обобщены.

#### Применение в проектировании ПО

В учебнике (стр. 5, раздел 5.6) подчеркивается, что IDEF0 используется в CASE-технологиях для анализа и проектирования. Модель IDEF0 помогает:  
- **На этапе анализа требований**: Определить функции системы, входные и выходные данные, а также управляющие условия (стр. 4, глава 4).  
- **На этапе проектирования**: Разбить функции на подфункции, спроектировать потоки данных и механизмы выполнения (стр. 5, глава 5).  
- **Для документирования**: Включить диаграммы в пояснительную записку (стр. 229), чтобы показать структуру системы.  

Например, для программы учета заказов диаграмма IDEF0 может показать функцию «Управление заказами» (A0), которая разбивается на «Ввод заказа» (A1), «Обработка заказа» (A2) и «Создание отчета» (A3), с указанием входов (данные клиента), управления (правила обработки), выходов (отчет) и механизмов (ПО, компьютер).

#### Итог

Метод SADT и стандарт IDEF0 позволяют моделировать функции системы и потоки данных в виде иерархических диаграмм. В IDEF0 функции представлены блоками, а их взаимодействие – стрелками входа, управления, выхода и механизма. Комбинированные стрелки, их разбиение и соединение уточняют потоки данных, а туннели упрощают диаграммы. Эти средства применяются для анализа, проектирования и документирования ПО, обеспечивая четкое описание системы в структурном подходе.

---
### 32. Построение моделей IDEF0: диаграммы, нумерация блоков и диаграмм, границы моделирования, наименование контекстного блока; типы связей между функциями: случайная, логическая, временная, процедурная, коммуникационная, последовательная, функциональная; дерево модели, презентационные диаграммы (FEO-диаграммы)

#### Построение моделей IDEF0

Модели IDEF0 – это функциональные модели, созданные по стандарту IDEF0 в рамках методологии SADT (Structured Analysis and Design Technique) для описания процессов системы. Учебник Г.С. Ивановой (стр. 4, раздел 4.4; стр. 5, раздел 5.6) упоминает IDEF0 как инструмент структурного подхода, используемый для анализа и проектирования программного обеспечения (ПО) с помощью диаграмм потоков данных и CASE-технологий. Ниже описаны ключевые аспекты построения моделей IDEF0, включая элементы, упомянутые в вопросе.

#### Диаграммы IDEF0

Диаграммы IDEF0 – это графическое представление функций системы и их взаимодействий. В учебнике (стр. 4, раздел 4.4) подчеркивается, что они показывают, как данные движутся между функциями. Основные характеристики:  
- **Структура**: Каждая диаграмма состоит из блоков (функций) и стрелок (потоков входа, управления, выхода, механизма).  
- **Иерархия**: Модель начинается с контекстной диаграммы (A-0), которая описывает систему как одну функцию, и далее детализируется в поддиаграммы (A0, A1, A2 и т.д.).  
- **Цель**: Описать, что делает система, какие данные использует и как взаимодействует с внешней средой.  

Например, для программы учета заказов контекстная диаграмма A-0 может называться «Управление заказами», а диаграмма A0 раскроет подфункции, такие как «Ввод заказа», «Обработка заказа» и «Создание отчета».

#### Нумерация блоков и диаграмм

- **Нумерация блоков**: Каждый блок (функция) на диаграмме имеет номер. На диаграмме A0 блоки нумеруются от 1 до 6 (например, A1, A2, A3). На следующем уровне детализации (например, диаграмма A1) блоки нумеруются как A11, A12 и т.д. Это отражает иерархию декомпозиции.  
- **Нумерация диаграмм**: Диаграммы обозначаются буквой «A» (Activity) и номером. Контекстная диаграмма – A-0 (минус ноль), первая декомпозиция – A0, её поддиаграммы – A1, A2 и т.д. Учебник (стр. 5, раздел 5.6) косвенно ссылается на иерархическую декомпозицию в CASE-технологиях.  
- **Пример**: Диаграмма A0 описывает функцию «Управление заказами», а диаграмма A1 – подфункцию «Ввод заказа» с блоками A11 («Ввод данных клиента»), A12 («Проверка данных»).

#### Границы моделирования

Границы моделирования определяют, что входит в модель, а что остается за её пределами. В IDEF0:  
- **Контекстная диаграмма (A-0)** задает границы системы, показывая её взаимодействие с внешней средой через входы, выходы, управление и механизмы.  
- **Внешние интерфейсы**: Стрелки, входящие в блок A-0 или исходящие из него, представляют данные или ресурсы от внешних систем. Например, «Данные клиента» от пользователя или «Отчет» для внешнего использования.  
- **Ограничения**: Границы определяются на этапе анализа требований (стр. 4, глава 4), чтобы фокусироваться только на релевантных функциях. Например, модель учета заказов может не включать функции управления складом.  

В учебнике (стр. 4, раздел 4.4) границы связаны с потоками данных, которые определяют, какие данные входят в систему и выходят из неё.

#### Наименование контекстного блока

Контекстный блок (A-0) – это единственный блок на контекстной диаграмме, представляющий всю систему.  
- **Наименование**: Должно быть кратким, описывать основную цель системы и использовать глагол + существительное. Например, «Управлять заказами», «Обрабатывать данные», «Контролировать процесс».  
- **Роль**: Задает общую функцию системы и её границы. В учебнике (стр. 4, раздел 4.3) функциональные диаграммы начинаются с общей функции, что соответствует контекстному блоку IDEF0.  
- **Пример**: Для ПО учета заказов контекстный блок может называться «Управлять заказами», с входами (данные клиента), управлением (правила обработки), выходами (отчет) и механизмами (ПО, компьютер).

#### Типы связей между функциями

В IDEF0 связи между функциями реализуются через стрелки, но стандарт не классифицирует их как случайные, логические и т.д. Однако в контексте учебника (стр. 4, раздел 4.4) и общего анализа SADT можно интерпретировать типы связей, основываясь на потоках данных и их роли:  
- **Случайная**: Поток данных возникает нерегулярно, зависит от внешних событий. Например, ввод данных пользователем, когда он решает добавить заказ.  
- **Логическая**: Поток управления, определяющий выполнение функции по условию. Например, «Если заказ валиден, обработать» (управляющая стрелка).  
- **Временная**: Поток, зависящий от последовательности во времени. Например, «Обработанный заказ» передается в функцию «Создать отчет» только после завершения обработки.  
- **Процедурная**: Поток, связанный с порядком выполнения функций. Например, «Введенный заказ» передается из «Ввод заказа» в «Обработка заказа».  
- **Коммуникационная**: Поток данных между функциями или с внешней средой. Например, «Данные клиента» от пользователя в функцию «Ввод заказа».  
- **Последовательная**: Поток, где выход одной функции становится входом другой. Например, «Введенный заказ» из A1 становится входом для A2.  
- **Функциональная**: Связь через общую цель, где функции вместе реализуют задачу. Например, A1, A2, A3 вместе обеспечивают «Управление заказами».  

В учебнике (стр. 4, раздел 4.4) связи отражены в диаграммах потоков данных, где стрелки показывают последовательность и зависимость функций.

#### Дерево модели

Дерево модели – это иерархическая структура, показывающая, как функции декомпозируются на подфункции.  
- **Структура**: Корень – контекстный блок A-0. Его дочерние узлы – блоки диаграммы A0 (A1, A2, A3). Каждый из них может иметь свои поддиаграммы (A11, A12 и т.д.).  
- **Назначение**: Помогает понять иерархию функций и организацию модели. В учебнике (стр. 5, раздел 5.3) структурные карты Константайна выполняют схожую роль, показывая иерархию функций.  
- **Пример**:  
  ```
  A-0: Управлять заказами
    ├── A1: Ввод заказа
    │     ├── A11: Ввод данных клиента
    │     └── A12: Проверка данных
    ├── A2: Обработка заказа
    └── A3: Создание отчета
  ```

#### Презентационные диаграммы (FEO-диаграммы)

FEO-диаграммы (For Exposition Only) – это дополнительные диаграммы в IDEF0, используемые для пояснений или презентаций.  
- **Назначение**: Упрощают или уточняют модель для обсуждения с заинтересованными сторонами (заказчиками, разработчиками). Могут показывать альтернативные виды функций или связей.  
- **Особенности**: Не являются обязательной частью стандарта IDEF0, но помогают визуализировать аспекты модели, которые трудно показать на основных диаграммах. Например, FEO-диаграмма может выделить только критические потоки данных.  
- **В учебнике**: Не упоминаются напрямую, но связаны с пояснительными схемами в документации (стр. 229), которые включаются в пояснительную записку для объяснения модели.  

#### Применение в проектировании ПО

В учебнике (стр. 5, раздел 5.6) IDEF0 применяется в CASE-технологиях для:  
- **Анализа требований**: Построение контекстной диаграммы и определение границ системы (стр. 4, глава 4).  
- **Проектирования**: Декомпозиция функций и проектирование потоков данных (стр. 5, глава 5).  
- **Документирования**: Включение диаграмм в пояснительную записку (стр. 229).  

Например, для ПО учета заказов дерево модели и диаграммы IDEF0 покажут, как функции ввода, обработки и отчетности связаны через потоки данных, а FEO-диаграмма может упростить модель для презентации заказчику.

#### Итог

Модели IDEF0 строятся из иерархических диаграмм, начинающихся с контекстного блока (A-0), который задает границы и цель системы. Блоки и диаграммы нумеруются по уровням декомпозиции (A0, A1, A11). Связи между функциями (случайные, логические, временные, процедурные, коммуникационные, последовательные, функциональные) отражают потоки данных и управления. Дерево модели показывает иерархию функций, а FEO-диаграммы упрощают презентацию. Эти элементы помогают анализировать, проектировать и документировать ПО в структурном подходе.

---
### 33. Метод описания процессов IDEF3: синтаксис и семантика моделей IDEF3: единица работы – действие (процесс); связи: временное предшествование, объектный поток, нечеткое отношение; соединения: «и», «или», «исключающее или»; синхронные и асинхронные соединения, парность соединений, комбинации соединений; указатели; декомпозиция действий

#### Метод описания процессов IDEF3

Метод IDEF3 (Integrated Definition for Process Description Capture Method) используется для моделирования и документирования процессов, описывая их последовательность, логику и взаимодействия. В отличие от IDEF0, который фокусируется на функциях, IDEF3 описывает, *как* процессы происходят во времени, включая их порядок и зависимости. Учебник Г.С. Ивановой (стр. 4, раздел 4.4; стр. 5, раздел 5.6) не упоминает IDEF3 напрямую, но обсуждает диаграммы потоков данных и CASE-технологии, которые близки по концепции. IDEF3 применяется для анализа процессов в структурном подходе, особенно при проектировании программного обеспечения (ПО).

#### Синтаксис и семантика моделей IDEF3

Модели IDEF3 состоят из диаграмм двух типов:  
- **Диаграммы описания процессов (Process Flow Diagrams)**: Показывают последовательность действий и их связи.  
- **Диаграммы переходов состояний объектов (Object State Transition Diagrams)**: Описывают изменения состояний объектов в процессе.  

Основной акцент в IDEF3 – на временной последовательности и логике процессов. Ниже описаны элементы, упомянутые в вопросе.

1. **Единица работы – действие (процесс)**  
   - **Синтаксис**: Действие (Unit of Work, UOW) изображается прямоугольником с закругленными углами, внутри которого указывается название процесса (глагол + существительное, например, «Обработать заказ»).  
   - **Семантика**: Представляет отдельный процесс или шаг в системе, который выполняет определенную задачу. Действие может включать входные и выходные данные, аналогично функциям в IDEF0.  
   - **В учебнике**: Сходно с блоками в диаграммах потоков данных (стр. 4, раздел 4.4), где процессы обрабатывают данные, например, модуль расчета в программе учета заказов.

2. **Связи**  
   IDEF3 использует стрелки для описания отношений между действиями:  
   - **Временное предшествование (Precedence Link)**: Простая стрелка, показывающая, что одно действие завершается перед началом другого. Например, «Ввод заказа» предшествует «Обработке заказа».  
   - **Объектный поток (Object Flow Link)**: Стрелка, указывающая, что объект (данные или ресурс) передается от одного действия к другому. Например, «Введенный заказ» переходит от «Ввод заказа» к «Обработка заказа».  
   - **Нечеткое отношение (Relational Link)**: Пунктирная стрелка, обозначающая неформальную или нестрогую связь между действиями, например, если порядок выполнения не фиксирован.  
   - **В учебнике**: Временное предшествование и объектный поток соответствуют потокам данных в диаграммах (стр. 4, раздел 4.4), где данные движутся между модулями в определенном порядке.

3. **Соединения**  
   Соединения (Junctions) – это точки, где стрелки сходятся или расходятся, определяя логику процесса. Изображаются кружками с символами:  
   - **«И» (And, &)**: Все входящие действия должны завершиться (для входящих стрелок) или все исходящие действия выполняются (для исходящих). Например, «Ввод данных» и «Проверка данных» должны завершиться перед «Обработкой заказа».  
   - **«Или» (Or, O)**: Выполняется хотя бы одно из входящих или исходящих действий. Например, заказ обрабатывается, если введены данные клиента *или* данные товара.  
   - **«Исключающее или» (Exclusive Or, X)**: Выполняется ровно одно из входящих или исходящих действий. Например, заказ либо принимается, либо отклоняется.  
   - **В учебнике**: Логика соединений косвенно отражена в диаграммах переходов состояний (стр. 4, раздел 4.2), где состояния программы зависят от условий.

4. **Синхронные и асинхронные соединения**  
   - **Синхронные соединения**: Указывают, что действия начинаются или заканчиваются одновременно. Обозначаются символом «S» в кружке соединения. Например, «Отправка отчета» и «Архивирование данных» начинаются вместе.  
   - **Асинхронные соединения**: Действия происходят независимо по времени, обозначаются символом «A». Например, «Проверка данных» может завершиться раньше, чем «Ввод заказа».  
   - **В учебнике**: Не упоминаются явно, но связаны с временной логикой в диаграммах потоков данных (стр. 4, раздел 4.4), где процессы могут зависеть от завершения предыдущих.

5. **Парность соединений**  
   - **Определение**: Соединения должны быть парными – для каждого входящего соединения (например, «И» для слияния стрелок) должно быть соответствующее исходящее соединение (например, «И» для ветвления). Это обеспечивает логическую целостность модели.  
   - **Пример**: Если два действия сходятся в соединение «И» перед «Обработкой заказа», то после обработки может быть исходящее соединение «И», разделяющее поток на два действия.  
   - **В учебнике**: Парность соответствует строгой структуре диаграмм в структурном подходе (стр. 11), где связи между модулями четко определены.

6. **Комбинации соединений**  
   - Соединения могут комбинироваться для описания сложной логики. Например, действие может требовать завершения двух процессов («И») и выбора одного из двух путей («Исключающее или»).  
   - **Пример**: «Обработка заказа» начинается, если завершены «Ввод данных» *и* «Проверка», а затем либо создается отчет, либо выдается ошибка («Исключающее или»).  
   - **В учебнике**: Сложные зависимости отражены в проектировании структур данных и алгоритмов (стр. 5, раздел 5.4), где данные обрабатываются по условиям.

7. **Указатели (Referents)**  
   - **Синтаксис**: Указатели – это аннотации (обычно кружки с номером или текстом), ссылающиеся на другие части модели, объекты или документы. Например, указатель может ссылаться на описание данных или другую диаграмму.  
   - **Семантика**: Упрощают модель, заменяя сложные элементы ссылками. Например, вместо детального описания «Данные клиента» указатель ссылается на их спецификацию.  
   - **В учебнике**: Аналогичны комментариям в пояснительной записке (стр. 229), которые ссылаются на другие части документации.

8. **Декомпозиция действий**  
   - **Синтаксис**: Действие (UOW) может быть разложено на поддействия, образуя новую диаграмму. Например, «Обработать заказ» декомпозируется в «Проверить данные», «Рассчитать сумму», «Обновить базу».  
   - **Семантика**: Позволяет детализировать процесс, сохраняя иерархию. Каждая поддиаграмма наследует входы, выходы и связи родительского действия.  
   - **В учебнике**: Декомпозиция соответствует методу пошаговой детализации (стр. 5, раздел 5.2) и иерархии функций в структурных картах Константайна (стр. 5, раздел 5.3).

#### Применение в проектировании ПО

В контексте учебника (стр. 5, раздел 5.6) IDEF3 применяется в CASE-технологиях для:  
- **Анализа требований**: Описание последовательности процессов и их зависимостей (стр. 4, глава 4).  
- **Проектирования**: Построение логики выполнения программы, включая временные и логические связи (стр. 5, глава 5).  
- **Документирования**: Включение диаграмм в пояснительную записку (стр. 229) для объяснения процессов.  

Например, для ПО учета заказов диаграмма IDEF3 может показать, что «Ввод заказа» предшествует «Обработке заказа» (временное предшествование), с объектным потоком «Введенный заказ» и соединением «И», требующим завершения ввода и проверки.

#### Итог

Метод IDEF3 описывает процессы через действия (UOW), связанные временным предшествованием, объектными потоками и нечеткими отношениями. Соединения («И», «Или», «Исключающее или») задают логику, синхронные и асинхронные соединения – временные зависимости, а парность и комбинации обеспечивают целостность. Указатели упрощают модель, а декомпозиция детализирует процессы. IDEF3 помогает анализировать, проектировать и документировать ПО, уточняя последовательность и логику процессов в структурном подходе.

---

### 34. Построение моделей IDEF3: диаграммы, нумерация блоков и диаграмм, сценарий, границы моделирования, определение действий и объектов

#### Построение моделей IDEF3

Метод IDEF3 (Integrated Definition for Process Description Capture Method) предназначен для моделирования процессов, описывая их последовательность, логику и взаимодействия во времени. В отличие от IDEF0, который фокусируется на функциях, IDEF3 акцентирует внимание на *процессах* и их временной динамике. Учебник Г.С. Ивановой (стр. 4, раздел 4.4; стр. 5, раздел 5.6) не упоминает IDEF3 напрямую, но обсуждает диаграммы потоков данных и CASE-технологии, которые концептуально близки. IDEF3 применяется в структурном подходе для анализа и проектирования программного обеспечения (ПО), особенно для описания последовательности действий.

#### Диаграммы IDEF3

Модели IDEF3 состоят из двух типов диаграмм:  
- **Диаграммы описания процессов (Process Flow Diagrams, PFD)**: Показывают последовательность действий, их связи и логику выполнения.  
- **Диаграммы переходов состояний объектов (Object State Transition Diagrams, OSTD)**: Описывают, как объекты изменяют свои состояния в ходе процесса.  

В учебнике (стр. 4, раздел 4.4) диаграммы потоков данных выполняют схожую роль, показывая движение данных между процессами. Диаграммы IDEF3:  
- **Структура**: Состоят из блоков (действий), стрелок (связей) и соединений (логических узлов).  
- **Иерархия**: Поддерживают декомпозицию, где сложные действия разбиваются на подпроцессы.  
- **Цель**: Зафиксировать, как процессы происходят, включая порядок, условия и объекты.  

Пример: Для ПО учета заказов диаграмма PFD может показать процесс от «Ввода заказа» до «Создания отчета», а OSTD – как заказ переходит из состояния «Введен» в «Обработан».

#### Нумерация блоков и диаграмм

- **Нумерация блоков**: Каждое действие (Unit of Work, UOW) обозначается как UOW с номером. На верхнем уровне блоки нумеруются UOW1, UOW2 и т.д. При декомпозиции добавляются подуровни, например, UOW1.1, UOW1.2.  
- **Нумерация диаграмм**: Диаграммы идентифицируются уникальными номерами или именами, связанными с процессом. Например, основная диаграмма может называться «Управление заказами», а её поддиаграммы – «Ввод заказа» (UOW1), «Обработка заказа» (UOW2).  
- **В учебнике**: Нумерация соответствует иерархии в структурных картах Константайна (стр. 5, раздел 5.3), где функции нумеруются по уровням декомпозиции.  
- **Пример**:  
  - UOW1: Ввод заказа  
  - UOW2: Обработка заказа  
  - UOW2.1: Проверка данных (подпроцесс UOW2).  

#### Сценарий

Сценарий в IDEF3 – это текстовое описание процесса, которое сопровождает диаграмму, поясняя её контекст, цель и последовательность действий.  
- **Содержание**: Описывает, что происходит в процессе, какие объекты задействованы, какие события запускают действия и какие результаты ожидаются.  
- **Роль**: Помогает заинтересованным сторонам (аналитикам, разработчикам) понять модель. Сценарий может быть основой для создания диаграмм или их проверки.  
- **В учебнике**: Сценарии связаны с предпроектными исследованиями (стр. 4, раздел 3.3), где описывается предметная область, и с пояснительной запиской (стр. 229), где документируются процессы.  
- **Пример сценария для учета заказов**:  
  1. Пользователь вводит данные клиента и заказа через интерфейс.  
  2. Система проверяет корректность данных.  
  3. Если данные верны, система обрабатывает заказ, рассчитывая сумму.  
  4. Система создает отчет или выдает сообщение об ошибке.  

#### Границы моделирования

Границы моделирования определяют, какие процессы и объекты входят в модель, а какие остаются за её пределами.  
- **Определение**: Границы задаются на основе целей моделирования, фиксируя внешние входы, выходы и взаимодействия. В IDEF3 границы видны на диаграммах PFD через начальные и конечные действия, а также внешние объекты.  
- **Внешние интерфейсы**: Стрелки, входящие в первое действие или исходящие из последнего, представляют взаимодействие с внешней средой. Например, «Данные клиента» от пользователя или «Отчет» для внешнего использования.  
- **В учебнике**: Границы соответствуют потокам данных в диаграммах (стр. 4, раздел 4.4), где определяются входные и выходные данные системы.  
- **Пример**: Для ПО учета заказов граница модели включает процессы ввода, проверки и обработки заказа, но исключает управление складом.

#### Определение действий и объектов

- **Действия (Units of Work, UOW)**:  
  - **Синтаксис**: Прямоугольник с закругленными углами, содержащий название (глагол + существительное, например, «Обработать заказ»).  
  - **Семантика**: Представляет процесс, который выполняет задачу, преобразует входы в выходы или изменяет состояние объектов.  
  - **Определение**: Действия идентифицируются на основе сценария и требований. Они должны быть четкими, с определенными входами, выходами и условиями выполнения.  
  - **В учебнике**: Действия аналогичны процессам в диаграммах потоков данных (стр. 4, раздел 4.4), например, модуль обработки данных.  
  - **Пример**: UOW1: Ввод заказа, UOW2: Проверка данных.

- **Объекты**:  
  - **Синтаксис**: Объекты (данные или ресурсы) обозначаются в объектных потоках (стрелки с названием, например, «Введенный заказ»). В OSTD объекты представлены состояниями.  
  - **Семантика**: Объекты – это сущности, участвующие в процессе, которые создаются, изменяются или используются действиями.  
  - **Определение**: Объекты определяются на основе предметной области. Например, в учете заказов объекты – «Заказ», «Клиент», «Отчет». Для каждого объекта в OSTD описываются состояния (например, «Заказ: Введен», «Заказ: Обработан»).  
  - **В учебнике**: Объекты связаны со структурами данных (стр. 5, раздел 5.4), где данные, такие как записи о клиентах, организованы для обработки.  
  - **Пример**: Объект «Заказ» с состояниями «Введен» → «Проверен» → «Обработан».

#### Применение в проектировании ПО

В учебнике (стр. 5, раздел 5.6) подчеркивается использование подобных моделей в CASE-технологиях для:  
- **Анализа требований**: Сценарии и диаграммы IDEF3 помогают описать процессы и объекты (стр. 4, глава 4).  
- **Проектирования**: Диаграммы уточняют последовательность действий и логику программы (стр. 5, глава 5).  
- **Документирования**: Диаграммы и сценарии включаются в пояснительную записку (стр. 229).  

Пример: Для ПО учета заказов диаграмма IDEF3 показывает, как «Ввод заказа» (UOW1) передает объект «Введенный заказ» в «Обработку заказа» (UOW2), а OSTD описывает переход заказа из состояния «Введен» в «Обработан».

#### Итог

Модели IDEF3 строятся из диаграмм PFD и OSTD, с нумерованными блоками (UOW1, UOW2) и иерархическими диаграммами. Сценарий описывает процесс текстуально, границы моделирования задают область анализа, а действия и объекты определяют процессы и данные. IDEF3 помогает анализировать, проектировать и документировать ПО, уточняя временную и логическую динамику процессов в структурном подходе.

---
### 35. Метод структурного анализа потоков данных: назначение диаграмм потоков данных (DFD); синтаксис и семантика DFD: функциональные блоки (системы и подсистемы, процессы), внешние сущности, потоки данных, хранилища данных, ветвление и объединение потоков данных

#### Метод структурного анализа потоков данных

Метод структурного анализа потоков данных (Data Flow Diagrams, DFD) – это инструмент структурного подхода, используемый для моделирования процессов системы и движения данных между ними. Учебник Г.С. Ивановой (стр. 4, раздел 4.4) подчеркивает, что DFD помогают описывать, как данные поступают в систему, обрабатываются и выводятся, что важно для анализа и проектирования программного обеспечения (ПО).

#### Назначение диаграмм потоков данных (DFD)

Диаграммы потоков данных предназначены для:  
- **Визуализации процессов**: Показывают, какие функции выполняет система и как они связаны через данные.  
- **Анализа требований**: Помогают понять, какие данные нужны системе, как они обрабатываются и куда направляются (стр. 4, глава 4).  
- **Проектирования**: Служат основой для декомпозиции системы на модули и проектирования их взаимодействия (стр. 5, глава 5).  
- **Документирования**: Используются в пояснительной записке для описания логики системы (стр. 229).  

В учебнике (стр. 4, раздел 4.4) DFD описаны как средство, показывающее движение данных от внешних источников через процессы к выходам, например, в программе учета заказов от ввода данных клиента к созданию отчета.

#### Синтаксис и семантика DFD

DFD состоят из стандартных элементов, каждый из которых имеет четкое значение. Учебник (стр. 4, раздел 4.4) упоминает их как часть анализа потоков данных. Ниже описаны элементы DFD:

1. **Функциональные блоки (системы и подсистемы, процессы)**  
   - **Синтаксис**: Процессы изображаются кругами или овалами с названием внутри (глагол + существительное, например, «Обработать заказ»). Системы и подсистемы могут быть представлены на верхнем уровне как единый процесс, который декомпозируется на подпроцессы.  
   - **Семантика**: Процесс представляет функцию, которая преобразует входные данные в выходные. Система (на контекстной диаграмме) – это вся модель, подсистемы – её крупные части, а процессы – конкретные действия.  
   - **Пример**: Процесс «Обработать заказ» принимает «Введенный заказ» и выдает «Обработанный заказ».  
   - **В учебнике**: Процессы соответствуют модулям в диаграммах потоков данных (стр. 4, раздел 4.4), которые обрабатывают данные, например, модуль расчета.

2. **Внешние сущности**  
   - **Синтаксис**: Прямоугольники (иногда с тенью) с названием, например, «Клиент» или «Администратор».  
   - **Семантика**: Представляют внешние источники или получатели данных, находящиеся за пределами системы. Это могут быть пользователи, другие системы или устройства.  
   - **Пример**: «Клиент» отправляет «Данные заказа» в систему или получает «Отчет».  
   - **В учебнике**: Упоминаются как внешние источники данных в диаграммах (стр. 4, раздел 4.4), взаимодействующие с системой.

3. **Потоки данных**  
   - **Синтаксис**: Стрелки с названием, соединяющие процессы, внешние сущности и хранилища. Например, стрелка «Данные заказа» от «Клиент» к «Ввод заказа».  
   - **Семантика**: Показывают движение данных (информации или объектов) между элементами системы. Поток описывает, какие данные передаются, но не как (реализация не уточняется).  
   - **Пример**: Поток «Обработанный заказ» идет от процесса «Обработать заказ» к процессу «Создать отчет».  
   - **В учебнике**: Потоки данных – основа диаграмм DFD (стр. 4, раздел 4.4), иллюстрирующая, как данные движутся через систему.

4. **Хранилища данных**  
   - **Синтаксис**: Два параллельных горизонтальных отрезка или открытый прямоугольник с названием, например, «База заказов».  
   - **Семантика**: Представляют место хранения данных, к которому процессы обращаются для записи или чтения. Хранилище – это база данных, файл или другой носитель.  
   - **Пример**: Процесс «Обработать заказ» записывает данные в «База заказов», а «Создать отчет» читает из неё.  
   - **В учебнике**: Хранилища связаны со структурами данных (стр. 5, раздел 5.4), где данные организованы для обработки.

5. **Ветвление и объединение потоков данных**  
   - **Синтаксис**:  
     - **Ветвление**: Одна стрелка разделяется на несколько с одинаковым названием, показывая, что данные передаются в разные процессы. Например, «Данные заказа» идут в «Проверить заказ» и «Сохранить заказ».  
     - **Объединение**: Несколько стрелок сливаются в одну, показывая, что данные из разных источников собираются. Например, «Данные клиента» и «Данные товара» объединяются в «Полный заказ».  
   - **Семантика**: Ветвление означает, что данные используются несколькими процессами одновременно, объединение – что процесс требует данных из нескольких источников.  
   - **Пример**: «Обработанный заказ» ветвится в «Создать отчет» и «Обновить базу».  
   - **В учебнике**: Ветвление и объединение отражены в сложных потоках данных (стр. 4, раздел 4.4), где данные распределяются или собираются.

#### Структура DFD

DFD строятся иерархически:  
- **Контекстная диаграмма**: Показывает систему как один процесс, взаимодействующий с внешними сущностями. Например, система «Управление заказами» с входом «Данные заказа» от «Клиент» и выходом «Отчет».  
- **Диаграммы уровня 0, 1 и т.д.**: Декомпозируют систему на подпроцессы. Например, уровень 0 включает процессы «Ввод заказа», «Обработка заказа», «Создание отчета».  

В учебнике (стр. 5, раздел 5.2) декомпозиция соответствует методу пошаговой детализации, где сложные функции разбиваются на простые.

#### Применение в проектировании ПО

В учебнике (стр. 5, раздел 5.6) DFD используются в CASE-технологиях для:  
- **Анализа требований**: Определение входов, выходов и процессов системы (стр. 4, глава 4).  
- **Проектирования**: Разбиение системы на модули и проектирование их интерфейсов (стр. 5, глава 5).  
- **Документирования**: Включение диаграмм в пояснительную записку (стр. 229).  

Пример: Для ПО учета заказов DFD показывает, как «Клиент» отправляет «Данные заказа» в процесс «Ввод заказа», который передает «Введенный заказ» в «Обработка заказа», записывая данные в «База заказов» и создавая «Отчет».

#### Итог

Метод структурного анализа потоков данных с помощью DFD визуализирует процессы, данные и их движение в системе. DFD включают функциональные блоки (процессы), внешние сущности, потоки данных и хранилища. Ветвление и объединение потоков показывают распределение и сбор данных. DFD применяются для анализа, проектирования и документирования ПО, обеспечивая четкое описание логики системы в структурном подходе.

---

### 36. Построение диаграмм потоков данных: нумерация объектов, построение контекстных диаграмм, правила детализации – балансировка, нумерация; спецификация процесса, требования, предъявляемые к спецификации, структурированный естественный язык описания спецификации процессов, верификация модели DFD – проверка на полноту и согласованность

#### Построение диаграмм потоков данных (DFD)

Диаграммы потоков данных (DFD) – это инструмент структурного анализа, используемый для моделирования процессов системы и потоков данных между ними. Учебник Г.С. Ивановой (стр. 4, раздел 4.4; стр. 5, раздел 5.6) подчеркивает их роль в анализе и проектировании программного обеспечения (ПО), показывая, как данные движутся от внешних источников через процессы к выходам. Ниже описаны аспекты построения DFD, упомянутые в вопросе.

#### Нумерация объектов

- **Синтаксис**: Объекты DFD (процессы, внешние сущности, хранилища данных) нумеруются для идентификации и отслеживания в иерархии.  
  - **Процессы**: Обозначаются номерами, отражающими уровень декомпозиции. На контекстной диаграмме процесс (вся система) не нумеруется или обозначается как 0. На уровне 0 процессы нумеруются 1, 2, 3 и т.д. На следующем уровне – 1.1, 1.2, 2.1 и т.д.  
  - **Внешние сущности**: Могут нумероваться (например, E1, E2) или обозначаться описательными именами (например, «Клиент»).  
  - **Хранилища данных**: Обозначаются как D1, D2 или именами (например, «База заказов»).  
  - **Потоки данных**: Не нумеруются, но имеют описательные названия (например, «Данные заказа»).  
- **Семантика**: Нумерация обеспечивает уникальность и связь между уровнями диаграмм, упрощая их анализ и документирование.  
- **В учебнике**: Нумерация соответствует иерархии в структурных картах Константайна (стр. 5, раздел 5.3), где функции нумеруются по уровням.  
- **Пример**:  
  - Процесс 1: Ввод заказа  
  - Процесс 1.1: Ввод данных клиента  
  - Хранилище D1: База заказов  
  - Внешняя сущность E1: Клиент  

#### Построение контекстных диаграмм

- **Синтаксис**: Контекстная диаграмма – это DFD верхнего уровня, представляющая систему как один процесс (круг или овал) с названием (например, «Управление заказами»). Внешние сущности (прямоугольники) взаимодействуют с системой через потоки данных (стрелки).  
- **Семантика**: Показывает границы системы, её взаимодействие с внешней средой (входы, выходы) и основные функции. Не включает хранилища данных и внутренние процессы.  
- **Шаги построения**:  
  1. Определить систему и её цель (например, «Управление заказами»).  
  2. Идентифицировать внешние сущности (например, «Клиент», «Администратор»).  
  3. Определить потоки данных (например, «Данные заказа» от «Клиент» к системе, «Отчет» от системы к «Клиент»).  
- **В учебнике**: Контекстные диаграммы связаны с определением границ системы в анализе требований (стр. 4, раздел 4.4).  
- **Пример**:  
  ```
  [Клиент] --> Данные заказа --> [Управление заказами] --> Отчет --> [Клиент]
  ```

#### Правила детализации – балансировка, нумерация

- **Балансировка**:  
  - **Определение**: Потоки данных на родительской диаграмме (например, контекстной) должны соответствовать потокам на дочерней диаграмме (уровень 0). Все входы и выходы системы на контекстной диаграмме должны быть отражены на следующем уровне.  
  - **Семантика**: Гарантирует согласованность модели, чтобы не было «потерянных» или «лишних» потоков.  
  - **Пример**: Если контекстная диаграмма имеет вход «Данные заказа» и выход «Отчет», то диаграмма уровня 0 должна включать эти же потоки, распределенные между процессами.  
  - **В учебнике**: Балансировка косвенно упоминается в методе пошаговой детализации (стр. 5, раздел 5.2), где декомпозиция сохраняет целостность системы.  

- **Нумерация при детализации**:  
  - Каждый уровень декомпозиции добавляет цифры к номеру процесса. Например, процесс 1 на уровне 0 декомпозируется в процессы 1.1, 1.2 на уровне 1.  
  - Хранилища и внешние сущности сохраняют свои обозначения на всех уровнях, но могут уточняться (например, D1 на уровне 0 разбивается на D1.1, D1.2).  
  - **В учебнике**: Нумерация отражена в иерархической структуре диаграмм (стр. 5, раздел 5.3).  
  - **Пример**: Процесс 1 «Ввод заказа» разбивается на 1.1 «Ввод данных клиента» и 1.2 «Проверка данных».

#### Спецификация процесса

- **Определение**: Спецификация процесса – это детальное описание, что делает каждый процесс в DFD. Она поясняет, как процесс преобразует входные данные в выходные.  
- **Синтаксис**: Обычно представлена текстом, псевдокодом, таблицами решений или формулами. В IDEF0 (стр. 5, раздел 5.6) спецификации могут быть частью CASE-технологий.  
- **Семантика**: Уточняет логику процесса, его входы, выходы, условия и алгоритмы. Например, для процесса «Обработать заказ» спецификация описывает расчет суммы заказа.  
- **В учебнике**: Спецификации связаны с описанием алгоритмов в проектировании (стр. 5, раздел 5.4) и пояснительной запиской (стр. 229).  
- **Пример**:  
  ```
  Процесс 2: Обработать заказ
  Входы: Введенный заказ
  Выходы: Обработанный заказ
  Логика: Проверить наличие товара, рассчитать сумму, обновить статус заказа.
  ```

#### Требования, предъявляемые к спецификации

- **Четкость**: Спецификация должна быть понятной для аналитиков, разработчиков и заказчиков.  
- **Полнота**: Должна описывать все входы, выходы, условия и действия процесса.  
- **Однозначность**: Исключать двусмысленности, используя формальные или структурированные описания.  
- **Соответствие DFD**: Все элементы спецификации (входы, выходы) должны совпадать с потоками на диаграмме.  
- **Проверяемость**: Логика должна быть тестируемой, чтобы подтвердить корректность процесса.  
- **В учебнике**: Требования к четкости и полноте отражены в правилах документирования (стр. 229) и проектирования модулей (стр. 11).

#### Структурированный естественный язык описания спецификации процессов

- **Определение**: Структурированный естественный язык – это способ описания процессов с использованием ограниченного набора слов и шаблонов, близких к естественному языку, но формализованных для однозначности.  
- **Синтаксис**: Используются стандартные конструкции, такие как:  
  - «Если [условие], то [действие]».  
  - «Для каждого [объект] выполнить [действие]».  
  - «Взять [вход], обработать, выдать [выход]».  
- **Семантика**: Обеспечивает читаемость для людей и формальность для анализа.  
- **Пример**:  
  ```
  Процесс: Обработать заказ
  Для каждого Введенного заказа:
    Если данные корректны, то:
      Рассчитать сумму заказа.
      Обновить статус заказа в Базе заказов.
      Выдать Обработанный заказ.
    Иначе:
      Выдать сообщение об ошибке.
  ```  
- **В учебнике**: Аналогичен описанию алгоритмов в проектировании (стр. 5, раздел 5.4), где используются простые конструкции для модулей.

#### Верификация модели DFD – проверка на полноту и согласованность

- **Полнота**:  
  - Все процессы, внешние сущности, хранилища и потоки данных должны быть определены.  
  - Каждый процесс должен иметь хотя бы один вход и один выход.  
  - Все данные, используемые в системе, должны иметь источник (внешняя сущность или другой процесс) и назначение.  
  - Хранилища должны иметь процессы, которые записывают и читают данные.  
  - **Пример проверки**: Убедиться, что «База заказов» имеет процесс записи (например, «Обработать заказ») и чтения (например, «Создать отчет»).  

- **Согласованность**:  
  - **Балансировка**: Потоки данных на родительской диаграмме должны совпадать с потоками на дочерней. Например, если контекстная диаграмма имеет вход «Данные заказа», он должен быть на уровне 0.  
  - **Соответствие спецификаций**: Спецификации процессов должны описывать все потоки, показанные в DFD.  
  - **Логическая целостность**: Потоки данных должны быть логичными (например, процесс не может выдавать данные, которых нет на входе).  
  - **Пример проверки**: Если процесс «Обработать заказ» выдает «Обработанный заказ», этот поток должен быть входом для следующего процесса или хранилища.  

- **В учебнике**: Верификация связана с тестированием и отладкой (стр. 5, глава 9), где проверяется корректность модели, и с документированием (стр. 229), где модель проверяется на полноту.  

#### Применение в проектировании ПО

В учебнике (стр. 5, раздел 5.6) DFD используются в CASE-технологиях для:  
- **Анализа требований**: Построение контекстных диаграмм и определение потоков данных (стр. 4, глава 4).  
- **Проектирования**: Декомпозиция процессов и создание спецификаций (стр. 5, глава 5).  
- **Документирования**: Включение диаграмм и спецификаций в пояснительную записку (стр. 229).  

Пример: Для ПО учета заказов контекстная диаграмма показывает взаимодействие с «Клиент», а диаграмма уровня 0 детализирует процессы «Ввод заказа», «Обработка заказа», «Создать отчет», с проверкой балансировки и спецификациями в структурированном языке.

#### Итог

Построение DFD включает нумерацию процессов (1, 1.1), внешних сущностей (E1) и хранилищ (D1), создание контекстной диаграммы для определения границ системы и детализацию с соблюдением балансировки. Спецификации процессов описывают их логику в структурированном естественном языке, отвечая требованиям четкости и полноты. Верификация DFD проверяет полноту (все элементы определены) и согласованность (балансировка, соответствие спецификаций). DFD обеспечивают анализ, проектирование и документирование ПО в структурном подходе.

---

### 37. Структуры данных: несвязанные, с неявными связями, с явными связями; иерархические модели Джексона-Орра

#### Структуры данных

Структуры данных – это способы организации и хранения данных в программе для их эффективной обработки. Учебник Г.С. Ивановой (стр. 5, раздел 5.4) подчеркивает, что проектирование структур данных – ключевой этап структурного подхода к разработке программного обеспечения (ПО), определяющий, как данные будут храниться и использоваться. Структуры данных классифицируются по типу связей между элементами: несвязанные, с неявными связями и с явными связями.

##### 1. Несвязанные структуры данных
- **Определение**: Элементы данных не имеют связей между собой и обрабатываются независимо.  
- **Синтаксис и семантика**: Данные представляют собой отдельные записи или значения, не объединенные в общую структуру. Например, набор чисел или строк, хранящихся в массиве без взаимосвязей.  
- **Примеры**:  
  - Список имен клиентов без указания отношений между ними.  
  - Массив температур за день, где каждый элемент независим.  
- **Применение**: Используются, когда данные не требуют связей, например, для простых списков или временных данных.  
- **В учебнике**: Упоминаются как простейшие структуры, которые не требуют сложной обработки (стр. 5, раздел 5.4).  

##### 2. Структуры данных с неявными связями
- **Определение**: Элементы данных связаны через их расположение или порядок, но связи не указаны явно (например, через указатели).  
- **Синтаксис и семантика**: Связь определяется позицией элемента в структуре, например, индексом в массиве или порядком в файле.  
- **Примеры**:  
  - Одномерный массив, где элементы связаны порядковыми номерами (например, `A[0]`, `A[1]`).  
  - Таблица, где строки и столбцы определяют отношения (например, таблица заказов, где каждая строка – запись).  
- **Применение**: Подходят для данных с фиксированной структурой, где порядок или позиция несут смысловую нагрузку.  
- **В учебнике**: Относятся к структурам, проектируемым для удобной обработки, например, массивы или списки (стр. 5, раздел 5.4).  

##### 3. Структуры данных с явными связями
- **Определение**: Элементы данных связаны явно через указатели, ссылки или другие механизмы, определяющие отношения.  
- **Синтаксис и семантика**: Каждый элемент содержит информацию о связанных элементах, например, указатель на следующий или родительский элемент.  
- **Примеры**:  
  - Связный список, где каждый узел содержит данные и указатель на следующий узел.  
  - Дерево, где узлы связаны указателями на дочерние или родительские узлы.  
  - Граф, где ребра явно соединяют вершины.  
- **Применение**: Используются для сложных данных с динамическими или иерархическими отношениями, например, в базах данных или системах управления.  
- **В учебнике**: Упоминаются как сложные структуры, такие как деревья или списки, для которых проектируются отношения (стр. 5, раздел 5.4).  

#### Иерархические модели Джексона-Орра

Иерархические модели Джексона-Орра – это метод проектирования структур данных и программ, предложенный Майклом Джексоном и дополненный Орром, основанный на отображении структур данных на алгоритмы. В учебнике (стр. 5, раздел 5.5) метод Джексона упоминается в контексте декомпозиции данных и проектирования программ.

- **Синтаксис**:  
  - Данные представляются в виде иерархических диаграмм (структурных диаграмм Джексона, JSD – Jackson Structure Diagrams).  
  - Диаграммы включают:  
    - **Последовательность**: Элементы следуют друг за другом (обозначается горизонтальной линией).  
    - **Выбор**: Один из нескольких элементов выбирается (обозначается кружком с «o»).  
    - **Повторение**: Элемент повторяется ноль или более раз (обозначается звездочкой «*»).  
  - Пример: Для файла заказов структура может быть:  
    ```
    Заказы
    ├── Заказ* (повторение)
    │   ├── Номер заказа
    │   ├── Данные клиента
    │   └── Товары (выбор)
    │       ├── Товар A
    │       └── Товар B
    ```

- **Семантика**:  
  - Модель описывает иерархию данных, отражая их логическую организацию.  
  - Структура данных напрямую влияет на алгоритм обработки: каждая диаграмма данных соответствует диаграмме программы.  
  - Например, иерархия «Заказы → Заказ → Товары» определяет, что программа должна последовательно обрабатывать заказы, а для каждого заказа – выбирать товары.  

- **Основные принципы**:  
  - **Соответствие данных и программы**: Структура данных должна зеркально отражаться в структуре программы (метод Джексона).  
  - **Декомпозиция**: Сложные данные разбиваются на простые компоненты, как в структурном подходе (стр. 5, раздел 5.5).  
  - **Иерархия**: Данные организованы в виде дерева, где каждый уровень уточняет предыдущий.  

- **Применение**:  
  - Проектирование структур данных для сложных систем, таких как базы данных или файловые системы.  
  - Разработка алгоритмов, которые обрабатывают данные в соответствии с их структурой.  
  - Пример: Для программы учета заказов модель Джексона-Орра описывает, как данные о заказах (список записей) разбиваются на поля (номер, клиент, товары), а программа следует этой же иерархии для обработки.  

- **В учебнике**: Метод Джексона упоминается как способ декомпозиции данных (стр. 5, раздел 5.5), где иерархические структуры помогают проектировать как данные, так и алгоритмы.  

#### Применение в проектировании ПО

В учебнике (стр. 5, разделы 5.4–5.5):  
- **Несвязанные структуры** используются для простых данных, таких как списки или массивы.  
- **Структуры с неявными связями** применяются в таблицах или массивах, где порядок важен.  
- **Структуры с явными связями** подходят для сложных систем, например, деревьев данных клиентов.  
- **Иерархические модели Джексона-Орра** помогают связать структуры данных с алгоритмами, обеспечивая их согласованность на этапе проектирования (стр. 5, глава 5) и документирования (стр. 229).  

Пример: Для ПО учета заказов несвязанные структуры могут хранить список имен клиентов, структуры с неявными связями – таблицу заказов, структуры с явными связями – дерево заказов с товарами, а модель Джексона-Орра описывает иерархию данных и соответствующий алгоритм обработки.

#### Итог

Структуры данных делятся на несвязанные (независимые элементы), с неявными связями (связи через порядок) и с явными связями (указатели). Иерархические модели Джексона-Орра представляют данные как деревья с последовательностью, выбором и повторением, связывая их с алгоритмами программы. Эти подходы обеспечивают эффективное проектирование данных и программ в структурном подходе, упоминаясь в учебнике как часть анализа и проектирования (стр. 5, разделы 5.4–5.5).
![[Pasted image 20250531073418.png]]
![[Pasted image 20250531073436.png]]

---

### 38. Моделирование данных – диаграммы «сущность-связь» (ERD): сущность, связь, атрибут

#### Моделирование данных с помощью диаграмм «сущность-связь» (ERD)

Диаграммы «сущность-связь» (Entity-Relationship Diagrams, ERD) – это инструмент моделирования данных, используемый для описания структуры данных и их взаимосвязей в системе. В учебнике Г.С. Ивановой (стр. 4, раздел 4.5; стр. 5, раздел 5.4) ERD упоминаются как средство проектирования структур данных в структурном подходе, помогающее организовать данные для программного обеспечения (ПО), например, для баз данных.

#### Основные элементы ERD

ERD состоят из трех ключевых компонентов: сущности, связи и атрибуты. Они позволяют формализовать данные и их отношения, обеспечивая основу для проектирования баз данных.

1. **Сущность (Entity)**  
   - **Синтаксис**: Изображается прямоугольником с названием внутри, например, «Клиент» или «Заказ».  
   - **Семантика**: Представляет объект или класс объектов реального мира, которые имеют общие характеристики и хранятся в системе. Сущность – это таблица в базе данных, где каждая запись (экземпляр сущности) описывает конкретный объект.  
   - **Типы сущностей**:  
     - **Сильная сущность**: Имеет уникальный идентификатор (ключ) и существует независимо. Например, «Клиент» с ключом «ID_Клиента».  
     - **Слабая сущность**: Зависит от другой сущности и не имеет уникального ключа без неё. Например, «Строка заказа», зависящая от «Заказ».  
   - **В учебнике**: Сущности связаны с проектированием структур данных (стр. 5, раздел 5.4), где данные организуются в виде записей, например, записи о клиентах.  
   - **Пример**: Сущность «Клиент» (содержит данные о клиентах) или «Заказ» (содержит данные о заказах).

2. **Связь (Relationship)**  
   - **Синтаксис**: Изображается ромбом (или линией в упрощенных ERD) с названием, соединяющим сущности. Например, ромб «Размещает» между «Клиент» и «Заказ».  
   - **Семантика**: Описывает, как сущности взаимодействуют друг с другом. Связи могут быть:  
     - **Один-к-одному (1:1)**: Один экземпляр сущности A связан с одним экземпляром сущности B. Например, «Клиент» имеет один «Паспорт».  
     - **Один-ко-многим (1:N)**: Один экземпляр A связан с несколькими экземплярами B. Например, один «Клиент» размещает несколько «Заказов».  
     - **Многие-ко-многим (M:N)**: Несколько экземпляров A связаны с несколькими экземплярами B. Например, «Заказ» включает несколько «Товаров», и каждый «Товар» может быть в нескольких «Заказах».  
   - **Кардинальность**: Указывает количество экземпляров в связи (например, 1, N). Обозначается на линиях связи (например, «1» или «*» для многих).  
   - **В учебнике**: Связи упоминаются в контексте диаграмм отношений компонентов данных (стр. 4, раздел 4.5), где описываются отношения между данными, например, между клиентами и заказами.  
   - **Пример**: Связь «Размещает» (1:N) между «Клиент» и «Заказ» означает, что один клиент может иметь много заказов.

3. **Атрибут (Attribute)**  
   - **Синтаксис**: Изображается овалом, соединенным с сущностью, с названием атрибута. Например, «Имя» или «ID_Клиента» для сущности «Клиент».  
   - **Семантика**: Описывает свойства или характеристики сущности. Каждый атрибут соответствует столбцу в таблице базы данных.  
   - **Типы атрибутов**:  
     - **Простой**: Неделимый, например, «Имя».  
     - **Составной**: Состоит из нескольких частей, например, «Адрес» (улица, город, индекс).  
     - **Ключевой**: Уникально идентифицирует экземпляр сущности, например, «ID_Клиента».  
     - **Многозначный**: Может иметь несколько значений, например, «Телефоны» клиента.  
     - **Производный**: Вычисляется из других атрибутов, например, «Возраст» из «Даты рождения».  
   - **В учебнике**: Атрибуты связаны с декомпозицией данных (стр. 5, раздел 5.5), где записи разбиваются на поля, такие как имя, адрес, номер заказа.  
   - **Пример**: Для сущности «Клиент» атрибуты: «ID_Клиента» (ключ), «Имя», «Адрес».

#### Построение ERD

- **Шаги**:  
  1. Идентифицировать сущности на основе предметной области (например, «Клиент», «Заказ», «Товар»).  
  2. Определить атрибуты для каждой сущности, выделяя ключевые.  
  3. Установить связи между сущностями, указав их тип (1:1, 1:N, M:N) и кардинальность.  
  4. Нарисовать диаграмму, используя прямоугольники (сущности), ромбы или линии (связи) и овалы (атрибуты).  
- **В учебнике**: Процесс построения ERD связан с проектированием структур данных (стр. 5, раздел 5.4) и анализом отношений данных (стр. 4, раздел 4.5).  
- **Пример для ПО учета заказов**:  
  ```
  [Клиент] ----(Размещает: 1:N)---- [Заказ]
    |                              |
    | Атрибуты:                  | Атрибуты:
    | - ID_Клиента (ключ)       | - ID_Заказа (ключ)
    | - Имя                     | - Дата
    | - Адрес                   | - Сумма
  ```

#### Применение ERD в проектировании ПО

В учебнике (стр. 5, разделы 5.4–5.5; стр. 4, раздел 4.5):  
- **Анализ требований**: ERD помогают определить, какие данные нужны системе и как они связаны (стр. 4, глава 4).  
- **Проектирование**: Используются для создания схемы базы данных, где сущности становятся таблицами, атрибуты – столбцами, а связи – внешними ключами (стр. 5, глава 5).  
- **Документирование**: Диаграммы включаются в пояснительную записку (стр. 229) для описания структуры данных.  

Пример: Для ПО учета заказов ERD показывает, что «Клиент» (с атрибутами «ID_Клиента», «Имя») через связь «Размещает» (1:N) связан с «Заказ» (с атрибутами «ID_Заказа», «Дата»), что помогает спроектировать базу данных.

#### Итог

Диаграммы «сущность-связь» (ERD) моделируют данные через сущности (объекты, например, «Клиент»), связи (взаимодействия, например, «Размещает») и атрибуты (свойства, например, «Имя»). ERD используются для анализа, проектирования и документирования структур данных в ПО, обеспечивая четкую организацию данных в структурном подходе, как описано в учебнике (стр. 4–5).

---

### 39. Метод Баркера

#### Метод Баркера

Метод Баркера – это подход к моделированию данных, основанный на использовании диаграмм «сущность-связь» (Entity-Relationship Diagrams, ERD), разработанный Ричардом Баркером. Он широко применялся в Oracle CASE-технологиях для проектирования баз данных. Учебник Г.С. Ивановой (стр. 4, раздел 4.5; стр. 5, раздел 5.6) не упоминает метод Баркера напрямую, но обсуждает диаграммы «сущность-связь» и CASE-технологии, которые близки по концепции. Метод Баркера отличается строгой нотацией и акцентом на практическое проектирование реляционных баз данных.

#### Основные принципы метода Баркера

Метод Баркера расширяет стандартные ERD, добавляя специфические правила и нотацию для большей ясности и однозначности. Он фокусируется на:  
- **Четком определении сущностей, связей и атрибутов**.  
- **Поддержке реляционного проектирования баз данных**.  
- **Упрощении понимания модели для аналитиков, разработчиков и заказчиков**.  

В контексте учебника (стр. 5, раздел 5.4), метод Баркера применим для проектирования структур данных, где данные организуются в виде сущностей и их отношений.

#### Синтаксис и семантика метода Баркера

1. **Сущности (Entities)**  
   - **Синтаксис**: Прямоугольник с закругленными углами, разделенный на две части: название сущности вверху и список атрибутов внизу. Например, сущность «Клиент» с атрибутами «ID_Клиента», «Имя».  
   - **Семантика**: Сущность представляет класс объектов с общими характеристиками, соответствующий таблице в базе данных. Каждая сущность должна иметь уникальный идентификатор (ключ).  
   - **Особенности Баркера**:  
     - Сущности строго именуются в единственном числе (например, «Клиент», а не «Клиенты»).  
     - Указывается, является ли сущность «сильной» (независимой) или «слабой» (зависимой).  
   - **Пример**:  
     ```
     +----------+
     | Клиент   |
     |----------|
     | #ID_Клиента |
     | Имя      |
     +----------+
     ```
     Здесь «#» обозначает ключевой атрибут.  

2. **Связи (Relationships)**  
   - **Синтаксис**: Линия между сущностями с названием связи (глагол или словосочетание, например, «размещает») и указанием кардинальности.  
   - **Семантика**: Описывает, как сущности взаимодействуют. Баркер использует специфическую нотацию для кардинальности:  
     - **Обязательность**: Сплошная линия означает обязательную связь (каждый экземпляр сущности должен участвовать в связи). Пунктирная линия – необязательная.  
     - **Кардинальность**: Воронья лапка («crow’s foot») обозначает «многие» (N), отсутствие лапки – «один» (1).  
     - Типы связей:  
       - **1:1** (один-к-одному): Редко используется, например, «Клиент имеет Паспорт».  
       - **1:N** (один-ко-многим): Например, «Клиент размещает Заказы».  
       - **M:N** (многие-ко-многим): Реализуется через промежуточную сущность, например, «Заказ содержит Товары» через сущность «Строка заказа».  
   - **Особенности Баркера**:  
     - Название связи читается в обоих направлениях (например, «Клиент размещает Заказ», «Заказ размещен Клиентом»).  
     - Кардинальность строго указывается с обеих сторон связи.  
   - **Пример**:  
     ```
     [Клиент] ---- размещает ----> [Заказ]
       | 1                N |
     ```
     Сплошная линия у «Заказ» означает, что заказ обязан иметь клиента; воронья лапка у «Заказ» – один клиент может иметь много заказов.  

3. **Атрибуты (Attributes)**  
   - **Синтаксис**: Перечисляются внутри прямоугольника сущности. Ключевые атрибуты помечаются символом «#», обязательные – звездочкой «*», необязательные – буквой «o».  
   - **Семантика**: Атрибуты описывают свойства сущности, соответствующие столбцам таблицы.  
   - **Особенности Баркера**:  
     - Обязательные атрибуты (например, «*Имя») должны иметь значение для каждого экземпляра.  
     - Ключевые атрибуты (например, «#ID_Клиента») уникальны.  
     - Поддерживаются составные и производные атрибуты, но они редко используются.  
   - **Пример**:  
     ```
     +----------+
     | Заказ    |
     |----------|
     | #ID_Заказа |
     | *Дата    |
     | oСумма   |
     +----------+
     ```

#### Построение модели по методу Баркера

- **Шаги**:  
  1. Определить сущности на основе предметной области (например, «Клиент», «Заказ», «Товар»).  
  2. Указать атрибуты для каждой сущности, выделяя ключевые и обязательные.  
  3. Определить связи, указав их направление, обязательность и кардинальность.  
  4. Нарисовать диаграмму с использованием нотации Баркера (прямоугольники с закругленными углами, линии с вороньими лапками).  
  5. Проверить модель на полноту и согласованность.  

- **В учебнике**: Процесс построения ERD описан в контексте проектирования структур данных (стр. 5, раздел 5.4) и анализа отношений данных (стр. 4, раздел 4.5). Метод Баркера уточняет этот процесс строгой нотацией.  

- **Пример для ПО учета заказов**:  
  ```
  +----------+       размещает       +----------+
  | Клиент   | ----1----------N----> | Заказ    |
  |----------|                       |----------|
  | #ID_Клиента |                    | #ID_Заказа |
  | *Имя      |                       | *Дата    |
  | oАдрес    |                       | oСумма   |
  +----------+                       +----------+
                                       |
                                       | содержит
                                       N
                                       |
                                       v
                                    +----------+
                                    | Товар    |
                                    |----------|
                                    | #ID_Товара |
                                    | *Название |
                                    | *Цена    |
                                    +----------+
  ```

#### Особенности метода Баркера

- **Простота и читаемость**: Нотация интуитивна, особенно для бизнес-аналитиков и заказчиков.  
- **Строгость**: Обязательность и кардинальность связей четко определены, что упрощает реализацию в реляционных базах данных.  
- **Поддержка CASE-инструментов**: Метод интегрирован в инструменты Oracle, такие как Oracle Designer, для автоматизации проектирования (стр. 5, раздел 5.6).  
- **Ограничения**: Менее гибок для сложных моделей (например, объектно-ориентированных) по сравнению с UML.  

#### Применение в проектировании ПО

В учебнике (стр. 4, раздел 4.5; стр. 5, разделы 5.4–5.5):  
- **Анализ требований**: Метод Баркера помогает определить сущности, их атрибуты и связи для предметной области (стр. 4, глава 4).  
- **Проектирование**: Используется для создания схемы базы данных, где сущности преобразуются в таблицы, атрибуты – в столбцы, а связи – во внешние ключи (стр. 5, глава 5).  
- **Документирование**: Диаграммы включаются в пояснительную записку (стр. 229) для описания структуры данных.  

Пример: Для ПО учета заказов метод Баркера позволяет спроектировать базу данных, где «Клиент» (таблица с полями «ID_Клиента», «Имя») через связь «размещает» связан с «Заказ» (таблица с полями «ID_Заказа», «Дата»), что обеспечивает четкую реляционную структуру.

#### Итог

Метод Баркера – это подход к моделированию данных с помощью ERD, использующий строгую нотацию для сущностей (прямоугольники с атрибутами), связей (линии с кардинальностью и обязательностью) и атрибутов (ключевые, обязательные, необязательные). Он упрощает проектирование реляционных баз данных, поддерживается CASE-технологиями и применим для анализа, проектирования и документирования ПО в структурном подходе, как указано в учебнике (стр. 4–5).

---

### 40. Метод IDEF1

#### Метод IDEF1

Метод IDEF1 (Integrated Definition for Information Modeling) – это стандарт моделирования данных, используемый для описания информационной структуры системы, включая сущности, их атрибуты и отношения. Он применяется в структурном подходе для проектирования баз данных и информационных систем. Учебник Г.С. Ивановой (стр. 4, раздел 4.5; стр. 5, раздел 5.4) не упоминает IDEF1 напрямую, но обсуждает моделирование данных и диаграммы отношений, которые концептуально близки. IDEF1 фокусируется на создании информационных моделей, аналогичных диаграммам «сущность-связь» (ERD), но с более строгой методологией.

#### Основные принципы метода IDEF1

IDEF1 предназначен для:  
- **Анализа информационных потребностей**: Определения, какие данные нужны системе и как они связаны.  
- **Проектирования баз данных**: Создания логической модели данных, которая может быть реализована в реляционной базе.  
- **Управления данными**: Обеспечения целостности и согласованности информации в системе.  

В контексте учебника (стр. 5, раздел 5.4), IDEF1 применим для проектирования структур данных, где данные организованы в виде сущностей и отношений, как при создании баз данных для ПО.

#### Синтаксис и семантика IDEF1

IDEF1 использует диаграммы, аналогичные ERD, но с акцентом на формализацию информационных отношений. Основные элементы:

1. **Сущности (Entities)**  
   - **Синтаксис**: Прямоугольник с названием сущности, например, «Клиент» или «Заказ».  
   - **Семантика**: Сущность представляет класс объектов, имеющих общие характеристики и хранимых в системе. Каждая сущность соответствует таблице в базе данных.  
   - **Типы сущностей**:  
     - **Независимая (Independent)**: Имеет уникальный ключ (идентификатор), например, «Клиент» с атрибутом «ID_Клиента».  
     - **Зависимая (Dependent)**: Не имеет уникального ключа без связи с другой сущностью, например, «Строка заказа», зависящая от «Заказ».  
   - **В учебнике**: Сущности соответствуют записям в структурах данных (стр. 5, раздел 5.4), например, записи о клиентах или заказах.  
   - **Пример**: Сущность «Клиент» с ключом «ID_Клиента».

2. **Атрибуты (Attributes)**  
   - **Синтаксис**: Список внутри или рядом с сущностью, с указанием ключевых и неключевых атрибутов. Например, «ID_Клиента», «Имя» для «Клиент».  
   - **Семантика**: Атрибуты описывают свойства сущности, соответствующие столбцам таблицы.  
   - **Типы атрибутов**:  
     - **Ключевой**: Уникально идентифицирует экземпляр сущности (например, «ID_Клиента»).  
     - **Неключевой**: Описывает дополнительные свойства (например, «Имя», «Адрес»).  
     - **Обязательный/необязательный**: Указывается, может ли атрибут быть пустым.  
   - **В учебнике**: Атрибуты связаны с декомпозицией данных (стр. 5, раздел 5.5), где записи разбиваются на поля.  
   - **Пример**: Для «Заказ» атрибуты: «ID_Заказа» (ключ), «Дата», «Сумма».

3. **Отношения (Relationships)**  
   - **Синтаксис**: Линия между сущностями с указанием типа отношения и кардинальности. Название отношения (например, «размещает») может быть указано.  
   - **Семантика**: Описывает, как сущности связаны. Отношения в IDEF1 делятся на:  
     - **Идентифицирующие**: Зависимая сущность определяется через связь с независимой (например, «Строка заказа» зависит от «Заказ»). Обозначается сплошной линией.  
     - **Неидентифицирующие**: Связь не влияет на идентификацию сущности (например, «Клиент» размещает «Заказ»). Обозначается пунктирной линией.  
   - **Кардинальность**:  
     - **Один-к-одному (1:1)**: Один экземпляр сущности A связан с одним экземпляром B.  
     - **Один-ко-многим (1:N)**: Один A связан с несколькими B.  
     - **Многие-ко-многим (M:N)**: Реализуется через промежуточную сущность.  
   - **В учебнике**: Отношения упоминаются в диаграммах отношений компонентов данных (стр. 4, раздел 4.5), где описываются связи, например, между клиентами и заказами.  
   - **Пример**: Отношение «размещает» (1:N) между «Клиент» и «Заказ» – неидентифицирующее, так как «Заказ» имеет собственный ключ.

#### Построение модели IDEF1

- **Шаги**:  
  1. **Идентификация сущностей**: Определить объекты предметной области (например, «Клиент», «Заказ», «Товар»).  
  2. **Определение атрибутов**: Указать ключевые и неключевые атрибуты для каждой сущности.  
  3. **Установление отношений**: Определить типы отношений (идентифицирующие/неидентифицирующие) и кардинальность.  
  4. **Построение диаграммы**: Нарисовать сущности (прямоугольники), атрибуты и связи (линии с указанием кардинальности).  
  5. **Верификация**: Проверить модель на полноту (все данные учтены) и согласованность (связи корректны).  

- **В учебнике**: Процесс построения моделей данных описан в контексте проектирования структур данных (стр. 5, раздел 5.4) и анализа отношений (стр. 4, раздел 4.5).  

- **Пример для ПО учета заказов**:  
  ```
  [Клиент] ---- размещает (1:N) ----> [Заказ]
    |                                |
    | Атрибуты:                    | Атрибуты:
    | - ID_Клиента (ключ)         | - ID_Заказа (ключ)
    | - Имя                       | - Дата
    | - Адрес                     | - Сумма
                                       |
                                       |---- содержит (M:N) ---- [Товар]
                                                |
                                                | Атрибуты:
                                                | - ID_Товара (ключ)
                                                | - Название
                                                | - Цена
  ```

#### Особенности IDEF1

- **Формализация**: IDEF1 более строг, чем стандартные ERD, с четкими правилами для идентифицирующих и неидентифицирующих отношений.  
- **Поддержка CASE-технологий**: Используется в автоматизированных инструментах проектирования (стр. 5, раздел 5.6).  
- **Фокус на информационной целостности**: Обеспечивает, что данные уникальны и согласованы, что важно для баз данных.  
- **Ограничения**: Меньше подходит для сложных объектно-ориентированных моделей по сравнению с UML.  

#### Применение в проектировании ПО

В учебнике (стр. 4, раздел 4.5; стр. 5, разделы 5.4–5.5):  
- **Анализ требований**: IDEF1 помогает определить данные и их связи для предметной области (стр. 4, глава 4).  
- **Проектирование**: Используется для создания логической модели базы данных, где сущности становятся таблицами, а отношения – внешними ключами (стр. 5, глава 5).  
- **Документирование**: Диаграммы включаются в пояснительную записку (стр. 229) для описания структуры данных.  

Пример: Для ПО учета заказов IDEF1-модель описывает, как «Клиент» (с ключом «ID_Клиента») через неидентифицирующее отношение «размещает» связан с «Заказ» (с ключом «ID_Заказа»), что обеспечивает основу для реляционной базы данных.

#### Сравнение с IDEF1X

IDEF1X – это расширенная версия IDEF1, оптимизированная для реляционных баз данных. Основные отличия:  
- IDEF1X добавляет нотацию для внешних ключей и нормализации.  
- IDEF1X более детализирован для реализации, тогда как IDEF1 фокусируется на концептуальной модели.  
- В учебнике (стр. 5, раздел 5.6) CASE-технологии могут подразумевать использование таких стандартов, как IDEF1X, для автоматизации проектирования.

#### Итог

Метод IDEF1 – это стандарт моделирования данных, использующий сущности (независимые и зависимые), атрибуты (ключевые и неключевые) и отношения (идентифицирующие и неидентифицирующие) для описания информационной структуры системы. Он применим для анализа, проектирования и документирования баз данных в структурном подходе, поддерживая проектирование структур данных, как указано в учебнике (стр. 4–5). IDEF1 обеспечивает формализованную основу для создания логических моделей данных, особенно в CASE-технологиях.


[Клиент] ---- размещает (1:N) ----> [Заказ]
  |                                |
  | Атрибуты:                    | Атрибуты:
  | - ID_Клиента (ключ)         | - ID_Заказа (ключ)
  | - Имя                       | - Дата
  | - Адрес                     | - Сумма
                                     |
                                     |---- содержит (M:N) ---- [Товар]
                                              |
                                              | Атрибуты:
                                              | - ID_Товара (ключ)
                                              | - Название
                                              | - Цена

---

### 41. Структурная и функциональная схемы: структурные схемы пакетов программ, программного комплекса, программной системы; функциональная схема-схема данных, основные обозначения по ГОСТ 19.701-90

#### Структурная и функциональная схемы

Структурные и функциональные схемы – это инструменты документирования и проектирования программного обеспечения (ПО), используемые в структурном подходе для описания организации и функционирования системы. Учебник Г.С. Ивановой (стр. 5, разделы 5.2–5.3; стр. 229) подчеркивает их роль в проектировании и включении в пояснительную записку. Структурные схемы описывают состав и связи компонентов ПО, а функциональные – процессы и потоки данных. ГОСТ 19.701-90 (Единая система программной документации. Схемы алгоритмов, программ, данных и систем) устанавливает стандарты для их оформления.

#### Структурные схемы

Структурные схемы показывают организацию компонентов ПО, их иерархию и взаимодействие. В учебнике (стр. 5, раздел 5.3) они связаны с декомпозицией системы на модули, аналогично структурным картам Константайна.

1. **Структурная схема пакета программ**  
   - **Определение**: Пакет программ – это набор программ, выполняющих связанные функции. Схема показывает состав пакета и связи между программами.  
   - **Синтаксис**:  
     - Прямоугольники – программы или модули с названиями (например, «Ввод данных», «Обработка»).  
     - Линии – связи, обозначающие вызовы или передачу данных.  
   - **Семантика**: Описывает, как программы в пакете взаимодействуют, например, через вызовы функций или общие данные.  
   - **Пример**: Пакет для учета заказов включает программы «Ввод заказа», «Обработка заказа», «Создание отчета», связанные вызовами.  
   - **В учебнике**: Соответствует модульной декомпозиции (стр. 5, раздел 5.2).  

2. **Структурная схема программного комплекса**  
   - **Определение**: Программный комплекс – это совокупность программ и данных для решения сложной задачи. Схема показывает программы, подсистемы и их взаимодействие.  
   - **Синтаксис**:  
     - Прямоугольники – подсистемы или программы.  
     - Линии – связи (например, обмен данными или управление).  
     - Иерархия – подсистемы могут включать программы.  
   - **Семантика**: Иллюстрирует архитектуру комплекса, включая зависимости и интерфейсы.  
   - **Пример**: Комплекс управления складом включает подсистемы «Учет заказов», «Управление запасами», связанные через базу данных.  
   - **В учебнике**: Относится к проектированию сложных систем (стр. 5, раздел 5.6).  

3. **Структурная схема программной системы**  
   - **Определение**: Программная система – это ПО в целом, включая программы, данные и ресурсы. Схема описывает её архитектуру.  
   - **Синтаксис**:  
     - Прямоугольники – компоненты (модули, подсистемы).  
     - Линии – связи (вызовы, передача данных).  
     - Внешние элементы – взаимодействие с пользователями или другими системами.  
   - **Семантика**: Показывает, как компоненты системы организованы и взаимодействуют для выполнения задач.  
   - **Пример**: Система учета заказов включает модули «Интерфейс», «Обработка», «База данных», связанные потоками данных.  
   - **В учебнике**: Соответствует общей структуре ПО (стр. 5, раздел 5.3).  

#### Функциональная схема – схема данных

Функциональная схема (схема данных) описывает процессы обработки данных и их движение в системе. В учебнике (стр. 4, раздел 4.4) она связана с диаграммами потоков данных (DFD), показывающими, как данные обрабатываются.

- **Определение**: Схема данных по ГОСТ 19.701-90 иллюстрирует процессы, потоки данных, хранилища и внешние взаимодействия, аналогично DFD.  
- **Синтаксис**:  
  - Процессы – круги или прямоугольники с названиями (например, «Обработать заказ»).  
  - Потоки данных – стрелки с названиями (например, «Данные заказа»).  
  - Хранилища данных – два параллельных отрезка или прямоугольник (например, «База заказов»).  
  - Внешние сущности – прямоугольники (например, «Клиент»).  
- **Семантика**: Показывает, как данные поступают в систему, обрабатываются и выводятся, описывая функциональность системы.  
- **Пример**: Схема данных для учета заказов показывает, как «Клиент» отправляет «Данные заказа» в процесс «Ввод заказа», который передает «Введенный заказ» в «Обработка заказа», сохраняя данные в «База заказов» и выдавая «Отчет».  
- **В учебнике**: Схемы данных соответствуют DFD (стр. 4, раздел 4.4) и используются для анализа и проектирования.  

#### Основные обозначения по ГОСТ 19.701-90

ГОСТ 19.701-90 устанавливает стандартные обозначения для схем, включая структурные и функциональные. Основные элементы, применимые к схемам данных и структурным схемам:

1. **Процесс (функция)**:  
   - **Обозначение**: Круг или прямоугольник с названием.  
   - **Пример**:  
     ```
     +-----------------+
     | Обработать заказ |
     +-----------------+
     ```
   - **Семантика**: Выполняет обработку данных, преобразуя входы в выходы.  

2. **Поток данных**:  
   - **Обозначение**: Стрелка с названием потока.  
   - **Пример**:  
     ```
     Данные заказа ---->
     ```
   - **Семантика**: Передача данных между процессами, хранилищами или внешними сущностями.  

3. **Хранилище данных**:  
   - **Обозначение**: Два параллельных отрезка или открытый прямоугольник с названием.  
   - **Пример**:  
     ```
     === База заказов ===
     ```
   - **Семантика**: Место хранения данных, доступное для чтения и записи.  

4. **Внешняя сущность**:  
   - **Обозначение**: Прямоугольник с названием.  
   - **Пример**:  
     ```
     +--------+
     | Клиент |
     +--------+
     ```
   - **Семантика**: Источник или получатель данных вне системы.  

5. **Связь (в структурных схемах)**:  
   - **Обозначение**: Линия, соединяющая модули или компоненты.  
   - **Пример**:  
     ```
     [Модуль 1] ---- [Модуль 2]
     ```
   - **Семантика**: Вызов, передача данных или управление между компонентами.  

6. **Условные обозначения**:  
   - **Ветвление/объединение потоков**: Стрелки, сходящиеся или расходящиеся от точки.  
   - **Комментарии**: Текст в рамке или без, поясняющий элементы.  
   - **Пример**:  
     ```
     Данные заказа ----> [точка ветвления] ----> Процесс 1
                                     ----> Процесс 2
     ```

#### Применение в проектировании ПО

В учебнике (стр. 4–5; стр. 229):  
- **Анализ требований**: Функциональные схемы (схемы данных) используются для определения процессов и потоков данных (стр. 4, раздел 4.4).  
- **Проектирование**: Структурные схемы описывают модули и их связи, а функциональные – логику обработки данных (стр. 5, разделы 5.2–5.3).  
- **Документирование**: Оба типа схем включаются в пояснительную записку (стр. 229) для описания системы.  

Пример: Для ПО учета заказов:  
- **Структурная схема**: Показывает модули «Интерфейс», «Обработка», «База данных», связанные вызовами.  
- **Функциональная схема**: Иллюстрирует, как «Клиент» отправляет «Данные заказа» в процесс «Ввод заказа», который передает данные в «База заказов» и процесс «Создать отчет».

#### Итог

Структурные схемы описывают организацию пакетов программ, программных комплексов и систем, показывая модули и их связи. Функциональные схемы (схемы данных) отображают процессы, потоки данных, хранилища и внешние сущности, аналогично DFD. ГОСТ 19.701-90 задает обозначения: круги/прямоугольники для процессов, стрелки для потоков, отрезки для хранилищ, прямоугольники для внешних сущностей. Эти схемы применяются для анализа, проектирования и документирования ПО в структурном подходе, как указано в учебнике (стр. 4–5, 229).

---

### 42. Проектирование структуры программного обеспечения с использованием метода пошаговой детализации: основное правило и рекомендации по применению

#### Метод пошаговой детализации

Метод пошаговой детализации (stepwise refinement) – это подход к проектированию программного обеспечения (ПО) в структурном подходе, при котором сложная задача последовательно разбивается на более простые подзадачи. Учебник Г.С. Ивановой (стр. 5, раздел 5.2) подчеркивает, что этот метод используется для проектирования структуры ПО сверху вниз, обеспечивая модульность и понятность программы.

#### Основное правило метода пошаговой детализации

**Основное правило**:  
Сложную задачу или программу следует разбивать на меньшие, более управляемые части (подзадачи или модули) поэтапно, начиная с общей функциональности и постепенно уточняя детали, пока каждая часть не станет достаточно простой для реализации.  

- **Семантика**:  
  - На каждом этапе проектирования создается уровень абстракции, где сложная функция описывается через совокупность более простых функций.  
  - Процесс продолжается до тех пор, пока подзадачи не станут элементарными (например, реализуемыми в 40–50 строк кода, как указано на стр. 11).  
  - Каждый уровень должен быть логически завершенным и проверяемым.  

- **В учебнике**: Это правило соответствует принципу декомпозиции (стр. 5, раздел 5.2), где сложная система разбивается на модули, проектируемые сверху вниз.  

- **Пример**: Для программы учета заказов общая задача «Управлять заказами» разбивается на подзадачи: «Ввод заказа», «Обработка заказа», «Создание отчета». Затем «Ввод заказа» делится на «Ввод данных клиента» и «Проверка данных».

#### Рекомендации по применению метода пошаговой детализации

Учебник (стр. 5, разделы 5.2–5.3) и общие принципы структурного подхода предлагают следующие рекомендации для эффективного использования метода:

1. **Начинать с общего описания системы**:  
   - Определить основную цель программы и её ключевые функции. Например, для ПО учета заказов – «обеспечить учет и обработку заказов».  
   - Создать контекстную модель (например, диаграмму потоков данных), чтобы понять входы, выходы и основные процессы (стр. 4, раздел 4.4).  

2. **Разбивать задачу на независимые модули**:  
   - Каждая подзадача должна быть функционально самостоятельной и иметь четкие входы и выходы.  
   - Модули должны быть слабо связаны (минимальное взаимодействие) и сильно сцеплены (внутренняя целостность).  
   - Пример: Модуль «Обработка заказа» независим от «Создания отчета», но использует его результаты.  

3. **Соблюдать иерархию проектирования**:  
   - Проектировать сверху вниз, переходя от общей структуры к деталям.  
   - Использовать иерархические схемы, такие как структурные карты Константайна (стр. 5, раздел 5.3), для визуализации уровней декомпозиции.  
   - Пример: На верхнем уровне – «Управлять заказами», на следующем – «Ввод», «Обработка», «Отчет», далее – подпроцессы, такие как «Проверка данных».  

4. **Ограничивать сложность модулей**:  
   - Каждый модуль должен быть простым (рекомендуемый размер – до 40–50 строк кода, стр. 11).  
   - Если модуль слишком сложен, его следует разбить на подмодули.  
   - Пример: Если «Обработка заказа» включает сложные вычисления, разбить её на «Рассчитать сумму» и «Обновить базу».  

5. **Использовать формальные модели для уточнения**:  
   - Применять диаграммы потоков данных (DFD, стр. 4, раздел 4.4) или функциональные диаграммы (стр. 4, раздел 4.3) для описания процессов и данных на каждом уровне.  
   - Уточнять модули с помощью спецификаций процессов (стр. 5, раздел 5.4).  
   - Пример: Для «Ввод заказа» создать DFD, показывающую потоки «Данные клиента» и «Введенный заказ».  

6. **Обеспечивать проверяемость**:  
   - Каждый уровень декомпозиции должен быть проверяемым (например, через тестирование модулей).  
   - Спецификации модулей должны быть четкими, чтобы можно было разработать тесты (стр. 5, глава 9).  
   - Пример: Проверить, что «Проверка данных» корректно отклоняет неверные заказы.  

7. **Соблюдать принципы структурного программирования**:  
   - Использовать только базовые конструкции: последовательность, выбор (if-then-else), цикл (while, for) (стр. 11).  
   - Избегать сложных переходов (goto), чтобы код был понятным и модульным.  
   - Пример: В модуле «Обработка заказа» использовать цикл для обработки списка товаров.  

8. **Документировать каждый этап**:  
   - Включать схемы и описания модулей в пояснительную записку (стр. 229).  
   - Использовать иерархические диаграммы и спецификации для пояснения структуры (стр. 5, раздел 5.3).  
   - Пример: Документировать модуль «Ввод заказа» с указанием его функций, входов и выходов.  

#### Применение в проектировании ПО

В учебнике (стр. 5, разделы 5.2–5.6):  
- **Анализ требований**: Метод начинается с определения общей задачи и её декомпозиции на подзадачи (стр. 4, глава 4).  
- **Проектирование**: Пошаговая детализация используется для создания модульной структуры программы, поддерживаемой диаграммами и CASE-технологиями (стр. 5, раздел 5.6).  
- **Реализация и тестирование**: Простые модули легче кодировать и проверять (стр. 5, глава 9).  
- **Документирование**: Иерархия модулей и их спецификации включаются в документацию (стр. 229).  

**Пример применения**:  
Для ПО учета заказов:  
1. Уровень 1: Определить задачу «Управлять заказами».  
2. Уровень 2: Разбить на модули «Ввод заказа», «Обработка заказа», «Создать отчет».  
3. Уровень 3: Детализировать «Ввод заказа» на «Ввод данных клиента» и «Проверка данных».  
4. Создать DFD для каждого уровня, специфицировать модули (например, «Проверка данных: если данные корректны, передать в обработку, иначе выдать ошибку»).  
5. Документировать структуру в пояснительной записке с иерархической схемой.
```
sequenceDiagram
    participant E as Ершов
    participant S as Студентик
    participant C as Кафедра
    participant A as Армия
    participant CBO as СВО
    
   
    E->>S: "Идешь на пересдачу!"
    S->>E: "Пощёл нахуй!"
    E->>S: "Отчислен!"
    S->>C: "Директор мудак(("
    C->>S: "Мы знаем))"
    S->>A: "Ну ёмае)" 
    A->>CBO: "Хехе)"
```

#### Итог

Метод пошаговой детализации проектирует структуру ПО, разбивая сложную задачу на простые модули сверху вниз. Основное правило – последовательное уточнение от общей функции к элементарным подзадачам. Рекомендации включают начало с общей модели, создание независимых модулей, соблюдение иерархии, ограничение сложности, использование формальных моделей, проверяемость, структурное программирование и документирование. Метод поддерживает анализ, проектирование и документирование ПО, как указано в учебнике (стр. 5, 229).


[Уровень 1]
Управлять заказами

[Уровень 2]
Управлять заказами
├── Ввод заказа
├── Обработка заказа
└── Создать отчет

[Уровень 3]
Ввод заказа
├── Ввод данных клиента
└── Проверка данных

---

### 43. Структурные карты Константайна: назначение, типы вызовов модулей – последовательный, параллельный, вызов сопрограммы; особые условия вызова – циклический, условный, однократный; диаграммы реализации параллельного вызова и вызова сопрограммы; типы связи – по данным, по управлению

#### Структурные карты Константайна

Структурные карты Константайна – это инструмент структурного подхода к проектированию программного обеспечения (ПО), предложенный Эдвардом Константайном, для описания иерархической структуры программы и взаимодействия её модулей. В учебнике Г.С. Ивановой (стр. 5, раздел 5.3) подчеркивается, что эти карты используются для декомпозиции системы на модули, визуализации их вызовов и связей, что упрощает проектирование и документирование.

#### Назначение структурных карт Константайна

- **Визуализация структуры ПО**: Карты показывают, как программа разбивается на модули и как они взаимодействуют.  
- **Поддержка декомпозиции**: Помогают разбить сложную задачу на простые подзадачи в методе пошаговой детализации (стр. 5, раздел 5.2).  
- **Определение вызовов и связей**: Уточняют, как модули вызывают друг друга и обмениваются данными или управлением.  
- **Проектирование и документирование**: Используются на этапе проектирования (стр. 5, глава 5) и включаются в пояснительную записку (стр. 229) для описания архитектуры программы.  

**Пример**: Для ПО учета заказов карта Константайна показывает, как главная функция «Управлять заказами» вызывает модули «Ввод заказа», «Обработка заказа» и «Создать отчет».

#### Типы вызовов модулей

Структурные карты Константайна описывают, как один модуль вызывает другой. В учебнике (стр. 5, раздел 5.3) упоминаются вызовы как часть организации модулей. Основные типы вызовов:

1. **Последовательный вызов**:  
   - **Синтаксис**: Модуль A вызывает модуль B, затем ожидает его завершения, прежде чем продолжить или вызвать модуль C.  
   - **Семантика**: Вызовы выполняются один за другим в строгом порядке.  
   - **Пример**: Модуль «Ввод заказа» завершает работу, после чего вызывается «Обработка заказа».  
   - **Диаграмма**:  
     ```
     [Управлять заказами]
           |
           v
     [Ввод заказа] --> [Обработка заказа]
     ```

2. **Параллельный вызов**:  
   - **Синтаксис**: Модуль A одновременно вызывает несколько модулей (B, C), которые выполняются независимо.  
   - **Семантика**: Подходит для многозадачных систем, где модули работают параллельно.  
   - **Пример**: Модуль «Создать отчет» вызывает «Форматировать данные» и «Печатать отчет» одновременно.  
   - **Диаграмма реализации**:  
     ```
     [Создать отчет]
        |      |
        v      v
     [Форматировать] [Печатать]
     ```

3. **Вызов сопрограммы**:  
   - **Синтаксис**: Модули A и B вызывают друг друга поочередно, сохраняя свое состояние между вызовами.  
   - **Семантика**: Используется для кооперативной многозадачности, где модули работают совместно, передавая управление.  
   - **Пример**: Модуль «Чтение данных» и «Обработка данных» чередуются, обрабатывая поток данных.  
   - **Диаграмма реализации**:  
     ```
     [Чтение данных] <--> [Обработка данных]
     ```

#### Особые условия вызова

Особые условия определяют, как и когда модуль вызывается. В учебнике (стр. 5, раздел 5.3) они связаны с логикой взаимодействия модулей.

1. **Циклический вызов**:  
   - **Синтаксис**: Модуль вызывается многократно в цикле. Обозначается стрелкой с пометкой «*» или «loop».  
   - **Семантика**: Используется для обработки повторяющихся данных или задач.  
   - **Пример**: Модуль «Обработать заказ» вызывается для каждого заказа в списке.  
   - **Диаграмма**:  
     ```
     [Управлять заказами]
           |
           v *
     [Обработать заказ]
     ```

2. **Условный вызов**:  
   - **Синтаксис**: Модуль вызывается только при выполнении условия. Обозначается стрелкой с пометкой «if» или ромбом.  
   - **Семантика**: Зависит от логики программы, например, проверки данных.  
   - **Пример**: Модуль «Создать отчет» вызывается, если заказ обработан успешно.  
   - **Диаграмма**:  
     ```
     [Обработка заказа]
           |
           v if(успех)
     [Создать отчет]
     ```

3. **Однократный вызов**:  
   - **Синтаксис**: Модуль вызывается ровно один раз. Обозначается обычной стрелкой без дополнительных меток.  
   - **Семантика**: Используется для уникальных операций.  
   - **Пример**: Модуль «Инициализация системы» вызывается при запуске программы.  
   - **Диаграмма**:  
     ```
     [Управлять заказами]
           |
           v
     [Инициализация]
     ```

#### Диаграммы реализации параллельного вызова и вызова сопрограммы

- **Параллельный вызов**:  
  - **Диаграмма**: Показывает модуль, вызывающий несколько подмодулей одновременно. Стрелки расходятся от вызывающего модуля к подмодулям.  
  - **Пример**:  
    ```
    [Создать отчет]
       |       |
       v       v
    [Форматировать] [Печатать]
    ```
  - **В учебнике**: Параллельные процессы косвенно упоминаются в контексте сложных систем (стр. 5, раздел 5.6).  

- **Вызов сопрограммы**:  
  - **Диаграмма**: Двусторонние стрелки между модулями, показывающие чередование вызовов.  
  - **Пример**:  
    ```
    [Чтение данных] <--> [Обработка данных]
    ```
  - **В учебнике**: Не описан явно, но связан с проектированием модулей с динамическим взаимодействием (стр. 5, раздел 5.3).  

#### Типы связи

Связи между модулями определяют, как они взаимодействуют. В учебнике (стр. 5, раздел 5.3) связи упоминаются как часть структуры программы.

1. **Связь по данным**:  
   - **Синтаксис**: Обозначается стрелкой с названием передаваемых данных (например, «Данные заказа»).  
   - **Семантика**: Модуль передает данные другому модулю для обработки.  
   - **Пример**: Модуль «Ввод заказа» передает «Введенный заказ» в «Обработка заказа».  
   - **Диаграмма**:  
     ```
     [Ввод заказа] --Данные заказа--> [Обработка заказа]
     ```

2. **Связь по управлению**:  
   - **Синтаксис**: Обозначается стрелкой с указанием управляющего сигнала (например, «Старт»).  
   - **Семантика**: Модуль передает команду или условие для выполнения другого модуля.  
   - **Пример**: Модуль «Управлять заказами» передает сигнал «Старт обработки» в «Обработка заказа».  
   - **Диаграмма**:  
     ```
     [Управлять заказами] --Старт--> [Обработка заказа]
     ```

#### Применение в проектировании ПО

В учебнике (стр. 5, разделы 5.2–5.6; стр. 229):  
- **Анализ требований**: Карты Константайна помогают определить основные функции и их декомпозицию (стр. 4, глава 4).  
- **Проектирование**: Используются для создания модульной структуры программы, уточняя вызовы и связи (стр. 5, раздел 5.3).  
- **Документирование**: Включаются в пояснительную записку (стр. 229) для описания архитектуры.  

**Пример**: Для ПО учета заказов карта Константайна показывает:  
- Главный модуль «Управлять заказами» последовательно вызывает «Ввод заказа», затем «Обработка заказа» (с циклическим вызовом для каждого заказа) и условно вызывает «Создать отчет».  
- Связь по данным: «Введенный заказ» от «Ввод» к «Обработка».  
- Связь по управлению: «Старт» от «Управлять» к «Обработка».

#### Итог

Структурные карты Константайна визуализируют иерархию и взаимодействие модулей ПО. Они описывают последовательные, параллельные вызовы и вызовы сопрограмм, с условиями циклического, условного или однократного вызова. Диаграммы реализации показывают параллельные и чередующиеся вызовы. Связи делятся на связи по данным (передача информации) и по управлению (передача команд). Карты применяются для проектирования и документирования ПО, как указано в учебнике (стр. 5, 229).

---

### 44. Проектирование структур данных: представление данных в оперативной памяти – векторная структура, списковые структуры; представление данных во внешней памяти – способы организации данных с последовательным и прямым доступом

#### Проектирование структур данных

Проектирование структур данных – это процесс выбора способов организации и хранения данных для эффективной обработки в программе. Учебник Г.С. Ивановой (стр. 5, раздел 5.4) подчеркивает, что структуры данных определяют, как данные хранятся в оперативной и внешней памяти, влияя на производительность и функциональность программного обеспечения (ПО). Структуры данных делятся на те, что используются в оперативной памяти (векторные, списковые), и во внешней памяти (с последовательным или прямым доступом).

#### Представление данных в оперативной памяти

Данные в оперативной памяти (RAM) хранятся для быстрого доступа и обработки во время выполнения программы. Учебник (стр. 5, раздел 5.4) упоминает массивы и списки как основные структуры.

1. **Векторная структура**  
   - **Определение**: Данные организованы в виде одномерного или многомерного массива, где элементы расположены последовательно в памяти.  
   - **Синтаксис и семантика**:  
     - Элементы имеют фиксированный размер и доступны по индексу (например, `array[i]`).  
     - Подходит для данных с неявными связями, где порядок или позиция определяют отношения.  
     - Примеры:  
       - Одномерный массив чисел: `[10, 20, 30]`.  
       - Двумерный массив (таблица): `[[1, 2], [3, 4]]`.  
   - **Преимущества**:  
     - Быстрый доступ по индексу (O(1)).  
     - Простота реализации.  
   - **Недостатки**:  
     - Фиксированный размер (в статических массивах).  
     - Вставка/удаление элементов требует сдвига (O(n)).  
   - **Применение**: Хранение списков, таблиц, матриц, например, массива заказов в ПО учета.  
   - **В учебнике**: Упоминается как структура с неявными связями (стр. 5, раздел 5.4).  
   - **Пример**: Массив `orders[100]` для хранения 100 заказов, где `orders[i]` – данные i-го заказа.

2. **Списковые структуры**  
   - **Определение**: Данные организованы в виде узлов, каждый из которых содержит данные и указатель на следующий (или предыдущий) узел.  
   - **Синтаксис и семантика**:  
     - Узел: `{данные, указатель}`.  
     - Типы:  
       - Односвязный список: каждый узел указывает на следующий.  
       - Двусвязный список: узлы указывают на следующий и предыдущий.  
       - Кольцевой список: последний узел связан с первым.  
     - Примеры:  
       - Односвязный список заказов: `Заказ1 -> Заказ2 -> null`.  
       - Двусвязный список клиентов: `Клиент1 <-> Клиент2 <-> Клиент3`.  
   - **Преимущества**:  
     - Динамический размер (легко добавлять/удалять узлы).  
     - Эффективная вставка/удаление (O(1) при известной позиции).  
   - **Недостатки**:  
     - Медленный доступ по индексу (O(n)).  
     - Дополнительная память для указателей.  
   - **Применение**: Хранение данных с явными связями, например, списка заказов с динамическим количеством.  
   - **В учебнике**: Относится к структурам с явными связями (стр. 5, раздел 5.4).  
   - **Пример**: Односвязный список, где каждый узел содержит данные заказа и указатель на следующий заказ.

#### Представление данных во внешней памяти

Данные во внешней памяти (на диске, в файлах, базах данных) хранятся для долговременного использования. Учебник (стр. 5, раздел 5.4) упоминает организацию данных в файлах и базах, акцентируя их связь с алгоритмами обработки.

1. **Последовательный доступ**  
   - **Определение**: Данные организованы в виде последовательного потока, где доступ к элементу требует чтения всех предыдущих.  
   - **Синтаксис и семантика**:  
     - Данные записываются и читаются в порядке их следования (например, в текстовом файле или ленте).  
     - Подходит для линейной обработки, например, чтения логов.  
     - Примеры:  
       - Текстовый файл с записями заказов, где каждая строка – заказ.  
       - Лог-файл операций: `Заказ1; Заказ2; Заказ3`.  
   - **Преимущества**:  
     - Простота организации.  
     - Экономия пространства (нет индексов).  
   - **Недостатки**:  
     - Медленный доступ к произвольному элементу (O(n)).  
     - Неэффективно для частых обновлений.  
   - **Применение**: Хранение логов, архивов, последовательных отчетов.  
   - **В учебнике**: Упоминается как способ хранения данных в файлах (стр. 5, раздел 5.4).  
   - **Пример**: Файл `orders.txt`, где каждая строка – запись заказа, читаемая последовательно.

2. **Прямой доступ**  
   - **Определение**: Данные организованы так, что к любому элементу можно получить доступ напрямую, используя адрес или ключ.  
   - **Синтаксис и семантика**:  
     - Данные хранятся с индексами, хэш-таблицами или в виде записей фиксированной длины.  
     - Подходит для быстрого поиска и обновления.  
     - Примеры:  
       - Файл с записями фиксированной длины, где заказ №N находится по смещению `N*размер_записи`.  
       - База данных с индексами: таблица «Заказы» с ключом «ID_Заказа».  
   - **Преимущества**:  
     - Быстрый доступ к данным (O(1) с индексами).  
     - Эффективно для обновлений и выборки.  
   - **Недостатки**:  
     - Дополнительная память для индексов.  
     - Сложность организации.  
   - **Применение**: Базы данных, индексированные файлы, системы с частым доступом к данным.  
   - **В учебнике**: Соответствует проектированию баз данных и структур с быстрым доступом (стр. 5, раздел 5.4).  
   - **Пример**: База данных, где запись заказа с `ID_Заказа=100` находится напрямую по индексу.

#### Применение в проектировании ПО

В учебнике (стр. 5, разделы 5.4–5.5):  
- **В оперативной памяти**:  
  - Векторные структуры используются для хранения фиксированных списков, например, массива заказов.  
  - Списковые структуры подходят для динамических данных, таких как список клиентов.  
- **Во внешней памяти**:  
  - Последовательный доступ применяется для логов или отчетов, например, файла с историей заказов.  
  - Прямой доступ используется в базах данных для быстрого поиска заказов по ID.  
- **Проектирование**: Выбор структуры данных влияет на алгоритмы обработки (стр. 5, раздел 5.5).  
- **Документирование**: Описание структур данных включается в пояснительную записку (стр. 229).  

**Пример**: Для ПО учета заказов:  
- В оперативной памяти: массив `orders[100]` (векторная структура) для текущих заказов и связный список для динамического добавления клиентов.  
- Во внешней памяти: база данных с таблицей «Заказы» (прямой доступ по ключу) и лог-файл операций (последовательный доступ).

#### Итог

Проектирование структур данных включает выбор способов хранения в оперативной памяти (векторные структуры – массивы, списковые – связные списки) и во внешней памяти (последовательный доступ – линейные файлы, прямой доступ – индексированные файлы или базы данных). Векторные структуры обеспечивают быстрый доступ, но фиксированы, списковые – гибки, но медленнее. Последовательный доступ прост, но медлен для выборки, прямой – быстр, но требует индексов. Эти подходы применяются для проектирования и документирования ПО, как указано в учебнике (стр. 5, 229).


[В оперативной памяти]
Векторная структура:
orders[100] = [Заказ1, Заказ2, ...] // Массив заказов

Списковая структура:
Клиент1 -> Клиент2 -> null
  | ID: 1 | Имя: Иван |   | ID: 2 | Имя: Мария |

[Во внешней памяти]
Последовательный доступ:
orders.txt:
Заказ1; Иван; 1000
Заказ2; Мария; 1500

Прямой доступ:
Таблица Заказы:

| ID_Заказа | Клиент | Сумма |
|-----------|--------|-------|
| 1         | Иван   | 1000  |
| 2         | Мария  | 1500  |

---

### 45. Проектирование программного обеспечения с использованием методов декомпозиции данных: метод Джексона, метод Варнье-Орра

#### Проектирование программного обеспечения с использованием методов декомпозиции данных

Методы декомпозиции данных фокусируются на проектировании программного обеспечения (ПО) путем анализа и структурирования данных, которые обрабатывает программа. Эти методы предполагают, что структура данных определяет структуру программы. Учебник Г.С. Ивановой (стр. 5, раздел 5.5) подчеркивает, что декомпозиция данных используется в структурном подходе для проектирования алгоритмов и структур данных, обеспечивая их согласованность. Два ключевых метода – метод Джексона и метод Варнье-Орра – основаны на иерархическом представлении данных и их отображении на программную логику.

#### Метод Джексона

Метод Джексона (Jackson Structured Programming, JSP), разработанный Майклом Джексоном, проектирует программы, исходя из структуры входных и выходных данных. В учебнике (стр. 5, раздел 5.5) он упоминается как способ декомпозиции данных, где структура данных напрямую влияет на алгоритм.

- **Основные принципы**:  
  - Программа должна отражать структуру данных, которые она обрабатывает.  
  - Входные и выходные данные представляются в виде иерархических диаграмм (Jackson Structure Diagrams, JSD).  
  - Алгоритм программы строится как отображение структуры данных на последовательность операций.  

- **Синтаксис и семантика**:  
  - **Диаграммы данных**:  
    - **Последовательность**: Элементы следуют друг за другом (обозначается горизонтальной линией).  
    - **Выбор**: Выбирается один из нескольких элементов (обозначается кружком с «o»).  
    - **Повторение**: Элемент повторяется ноль или более раз (обозначается звездочкой «*»).  
    - Пример: Для файла заказов:  
      ```
      Заказы
      ├── Заказ* (повторение)
      │   ├── Номер заказа
      │   ├── Данные клиента
      │   └── Товары (выбор)
      │       ├── Товар A
      │       └── Товар B
      ```
  - **Диаграммы программы**:  
    - Строятся по структуре данных, используя те же конструкции (последовательность, выбор, повторение).  
    - Каждая операция в программе соответствует элементу данных.  
    - Пример: Программа обработки заказов:  
      ```
      Обработать заказы
      ├── Для каждого заказа*:
      │   ├── Прочитать номер
      │   ├── Прочитать данные клиента
      │   └── Если товары:
      │       ├── Обработать товар A
      │       └── или товар B
      ```

- **Процесс проектирования**:  
  1. Построить диаграмму входных данных (например, структура файла заказов).  
  2. Построить диаграмму выходных данных (например, структура отчета).  
  3. Создать диаграмму программы, отображающую данные на операции.  
  4. Преобразовать диаграмму в псевдокод или код.  
  5. Уточнить обработку ошибок и особых случаев (например, пустой файл).  

- **Преимущества**:  
  - Простота проектирования для программ с четкой структурой данных.  
  - Легкость проверки соответствия программы данным.  
- **Недостатки**:  
  - Сложность при неструктурированных или сложных данных.  
  - Ограниченная применимость для интерактивных систем.  

- **В учебнике**: Метод Джексона упоминается как способ декомпозиции данных, где иерархия данных определяет алгоритм (стр. 5, раздел 5.5).  
- **Пример**: Для ПО учета заказов диаграмма данных описывает файл «Заказы» с повторяющимися записями, а программа последовательно читает и обрабатывает каждый заказ.

#### Метод Варнье-Орра

Метод Варнье-Орра, разработанный Жаном-Домиником Варнье и дополненный Кеннетом Орром, также основан на декомпозиции данных, но использует более простую нотацию и акцентирует иерархическую организацию. В учебнике (стр. 5, раздел 5.5) он связан с проектированием структур данных и алгоритмов.

- **Основные принципы**:  
  - Данные представляются в виде иерархической структуры, которая определяет порядок их обработки.  
  - Программа строится как последовательность операций, отражающая иерархию данных.  
  - Используется нотация Варнье-Орра (диаграммы с фигурными скобками) для визуализации.  

- **Синтаксис и семантика**:  
  - **Диаграммы Варнье-Орра**:  
    - **Последовательность**: Элементы записываются сверху вниз.  
    - **Повторение**: Обозначается числом повторений или «*» (ноль или более).  
    - **Выбор**: Обозначается символом «+» для взаимоисключающих вариантов.  
    - **Иерархия**: Фигурные скобки показывают вложенность.  
    - Пример: Для файла заказов:  
      ```
      Заказы {
        Заказ (0..N) {
          Номер заказа
          Данные клиента
          Товары {
            Товар A + Товар B
          }
        }
      }
      ```
  - **Диаграммы программы**:  
    - Операции соответствуют структуре данных, следуя той же иерархии.  
    - Пример:  
      ```
      Обработать заказы {
        Для каждого заказа (0..N) {
          Прочитать номер
          Прочитать данные клиента
          Если товар A {
            Обработать A
          } иначе если товар B {
            Обработать B
          }
        }
      }
      ```

- **Процесс проектирования**:  
  1. Определить структуру входных и выходных данных с помощью диаграммы Варнье-Орра.  
  2. Построить иерархию операций, соответствующую структуре данных.  
  3. Преобразовать диаграмму в псевдокод или код.  
  4. Добавить обработку исключений и условий.  

- **Преимущества**:  
  - Простая и наглядная нотация.  
  - Подходит для проектирования программ с иерархическими данными.  
- **Недостатки**:  
  - Ограниченная применимость для сложных или неиерархических данных.  
  - Меньшая гибкость по сравнению с современными методами (например, UML).  

- **В учебнике**: Метод Варнье-Орра упоминается как способ организации данных и алгоритмов, особенно для иерархических структур (стр. 5, раздел 5.5).  
- **Пример**: Для ПО учета заказов диаграмма Варнье-Орра описывает файл «Заказы» как иерархию, а программа следует этой структуре для обработки данных.

#### Сравнение методов Джексона и Варнье-Орра

| Характеристика             | Метод Джексона                          | Метод Варнье-Орра                      |
|----------------------------|-----------------------------------------|-----------------------------------------|
| **Нотация**                | Диаграммы с последовательностью, выбором, повторением | Фигурные скобки с иерархией, «+» для выбора |
| **Фокус**                  | Отображение данных на программу         | Иерархическая организация данных        |
| **Сложность**              | Более детализированная                  | Простая и компактная                    |
| **Применение**             | Программы с четкой структурой данных    | Программы с иерархическими данными      |
| **В учебнике**             | стр. 5, раздел 5.5                     | стр. 5, раздел 5.5                     |

#### Применение в проектировании ПО

В учебнике (стр. 5, разделы 5.4–5.5; стр. 229):  
- **Анализ требований**: Методы помогают определить структуру данных для предметной области (стр. 4, глава 4).  
- **Проектирование**: Используются для создания алгоритмов, где структура данных определяет логику программы (стр. 5, глава 5).  
- **Документирование**: Диаграммы включаются в пояснительную записку (стр. 229) для описания данных и алгоритмов.  

**Пример**: Для ПО учета заказов:  
- **Метод Джексона**: Диаграмма данных описывает файл «Заказы» с повторяющимися записями, программа строится как цикл обработки заказов.  
- **Метод Варнье-Орра**: Диаграмма с фигурными скобками показывает иерархию «Заказы → Заказ → Товары», программа следует этой же структуре.

#### Итог

Методы декомпозиции данных – Джексона и Варнье-Орра – проектируют ПО, отображая структуру данных на алгоритмы. Метод Джексона использует диаграммы с последовательностью, выбором и повторением, метод Варнье-Орра – иерархические диаграммы с фигурными скобками. Оба метода подходят для программ с четкой структурой данных, поддерживая анализ, проектирование и документирование, как указано в учебнике (стр. 5, 229).


[Метод Джексона]
Заказы
├── Заказ* (повторение)
│   ├── Номер заказа
│   ├── Данные клиента
│   └── Товары (выбор)
│       ├── Товар A
│       └── Товар B

Программа:
Обработать заказы
├── Для каждого заказа*:
│   ├── Прочитать номер
│   ├── Прочитать данные клиента
│   └── Если товары:
│       ├── Обработать товар A
│       └── или товар B

[Метод Варнье-Орра]
Заказы {
  Заказ (0..N) {
    Номер заказа
    Данные клиента
    Товары {
      Товар A + Товар B
    }
  }
}

Программа:
Обработать заказы {
  Для каждого заказа (0..N) {
    Прочитать номер
    Прочитать данные клиента
    Если товар A {
      Обработать A
    } иначе если товар B {
      Обработать B
    }
  }
}

---

### 46. Структурный подход к проектированию программного обеспечения: основные достоинства и недостатки, особенности применения, перспективы развития

#### Структурный подход к проектированию программного обеспечения

Структурный подход к проектированию программного обеспечения (ПО) – это методология разработки, основанная на декомпозиции системы на модули, использовании строгих методов проектирования (например, пошаговой детализации) и формальных моделей (DFD, ERD, IDEF). Учебник Г.С. Ивановой (стр. 4–5, разделы 4.3–5.6) подчеркивает его роль в создании структурированных, модульных программ с четкой организацией. Структурный подход включает методы, такие как проектирование сверху вниз, структурное программирование и моделирование данных/процессов.

#### Основные достоинства

1. **Модульность и структурированность**:  
   - Система разбивается на независимые модули с четкими интерфейсами, что упрощает разработку и сопровождение (стр. 5, раздел 5.2).  
   - Пример: В ПО учета заказов модули «Ввод заказа» и «Обработка заказа» проектируются отдельно.  

2. **Четкость проектирования**:  
   - Использование формальных моделей (DFD, ERD, структурные карты Константайна) обеспечивает однозначное описание системы (стр. 4, раздел 4.4; стр. 5, раздел 5.3).  
   - Пример: DFD показывает потоки данных, такие как «Данные заказа» от «Клиент» к «Обработка».  

3. **Поддержка пошаговой детализации**:  
   - Метод позволяет разбивать сложные задачи на простые подзадачи, упрощая реализацию (стр. 5, раздел 5.2).  
   - Пример: Задача «Управлять заказами» делится на «Ввод», «Обработка», «Отчет».  

4. **Улучшение тестирования и отладки**:  
   - Модульная структура облегчает тестирование отдельных компонентов (стр. 5, глава 9).  
   - Пример: Тестирование модуля «Проверка данных» независимо от «Обработки заказа».  

5. **Документируемость**:  
   - Формальные схемы и спецификации включаются в пояснительную записку, упрощая сопровождение (стр. 229).  
   - Пример: Диаграммы DFD и ERD документируют процессы и данные.  

6. **Поддержка CASE-технологий**:  
   - Структурный подход интегрируется с автоматизированными инструментами проектирования (стр. 5, раздел 5.6).  
   - Пример: Использование Oracle Designer для построения IDEF-моделей.  

#### Основные недостатки

1. **Ограниченная гибкость**:  
   - Подход плохо подходит для систем с нечеткими требованиями или частыми изменениями, так как требует строгого планирования (стр. 4, раздел 4.3).  
   - Пример: Изменение требований к интерфейсу может потребовать переработки всей модели.  

2. **Сложность масштабирования**:  
   - Для крупных систем декомпозиция может стать громоздкой, увеличивая сложность управления модулями (стр. 5, раздел 5.3).  
   - Пример: Система с сотнями модулей трудно поддерживается без дополнительных инструментов.  

3. **Фокус на процессах и данных**:  
   - Структурный подход менее эффективен для объектно-ориентированных систем, где важны объекты и их поведение, а не только данные и процессы (стр. 5, раздел 5.6).  
   - Пример: Моделирование сложных взаимодействий в GUI сложнее с DFD, чем с UML.  

4. **Ограниченная поддержка параллелизма**:  
   - Подход изначально ориентирован на последовательные процессы, что усложняет проектирование многозадачных систем (стр. 5, раздел 5.3).  
   - Пример: Параллельная обработка заказов требует дополнительных усилий в нотации Константайна.  

5. **Затраты на начальное проектирование**:  
   - Требует значительных усилий на создание формальных моделей, что может замедлить разработку (стр. 4, раздел 4.4).  
   - Пример: Построение DFD и ERD для небольшой системы может быть избыточным.  

#### Особенности применения

1. **Этапы применения**:  
   - **Анализ требований**: Используются DFD и ERD для описания процессов и данных (стр. 4, разделы 4.4–4.5).  
   - **Проектирование**: Применяется пошаговая детализация и структурные карты Константайна для создания модульной структуры (стр. 5, разделы 5.2–5.3).  
   - **Реализация**: Структурное программирование с базовыми конструкциями (последовательность, выбор, цикл) обеспечивает читаемый код (стр. 11).  
   - **Тестирование**: Модули тестируются отдельно (стр. 5, глава 9).  
   - **Документирование**: Схемы и спецификации включаются в документацию (стр. 229).  

2. **Инструменты**:  
   - CASE-технологии (например, Oracle Designer) автоматизируют построение моделей IDEF, DFD, ERD (стр. 5, раздел 5.6).  
   - Пример: Генерация схем базы данных из ERD.  

3. **Предметные области**:  
   - Подход эффективен для систем с четкими процессами и данными, таких как учетные системы, базы данных, системы управления (стр. 4, глава 4).  
   - Пример: ПО учета заказов с модулями «Ввод», «Обработка», «Отчет».  

4. **Ограничения применения**:  
   - Менее подходит для интерактивных, реального времени или распределенных систем, где важны события и состояния (стр. 5, раздел 5.6).  
   - Пример: Сложно моделировать веб-приложение с динамическим интерфейсом.  

#### Перспективы развития

1. **Интеграция с современными подходами**:  
   - Структурный подход может комбинироваться с объектно-ориентированным программированием (ООП) и UML, используя DFD для процессов и ERD для данных, а UML – для объектов (стр. 5, раздел 5.6).  
   - Пример: Использование DFD для анализа процессов и UML-диаграмм классов для проектирования.  

2. **Автоматизация проектирования**:  
   - CASE-инструменты развиваются, интегрируясь с DevOps и CI/CD, что упрощает генерацию кода и документации из структурных моделей.  
   - Пример: Инструменты, такие как Enterprise Architect, поддерживают IDEF и UML.  

3. **Гибридные методологии**:  
   - Структурный подход адаптируется к Agile, где модульная декомпозиция используется для итеративной разработки (не упоминается в учебнике, но актуально на 2025 год).  
   - Пример: DFD для прототипирования процессов в спринтах.  

4. **Ограниченные перспективы в новых областях**:  
   - Для систем с искусственным интеллектом, микросервисами или облачными архитектурами структурный подход уступает более гибким методологиям (например, микросервисной архитектуре), так как не поддерживает динамические взаимодействия.  
   - Пример: Моделирование нейросетей требует других подходов.  

5. **Образовательная роль**:  
   - Структурный подход остается важным для обучения принципам проектирования, модульности и декомпозиции (стр. 5, глава 5).  
   - Пример: Студенты изучают DFD и ERD для понимания основ проектирования баз данных.  

#### Применение в проектировании ПО

В учебнике (стр. 4–5, 229):  
- **Анализ**: DFD и ERD описывают процессы и данные (стр. 4, разделы 4.4–4.5).  
- **Проектирование**: Пошаговая детализация, структурные карты Константайна и методы декомпозиции данных (Джексона, Варнье-Орра) создают модульную архитектуру (стр. 5, разделы 5.2–5.5).  
- **Документирование**: Схемы включаются в пояснительную записку (стр. 229).  

**Пример**: Для ПО учета заказов структурный подход:  
- Использует DFD для моделирования процессов («Ввод заказа» → «Обработка»).  
- Применяет ERD для проектирования базы данных («Клиент» – «Заказ»).  
- Разбивает систему на модули («Ввод», «Обработка», «Отчет») с помощью пошаговой детализации.  
- Документирует архитектуру с помощью структурных карт Константайна.  

#### Итог

Структурный подход к проектированию ПО обеспечивает модульность, четкость и тестируемость благодаря декомпозиции, формальным моделям (DFD, ERD, IDEF) и структурному программированию. Его достоинства – модульность, документируемость, поддержка CASE-технологий; недостатки – ограниченная гибкость, сложность масштабирования, слабая поддержка параллелизма. Подход применяется в системах с четкими процессами (например, учетные системы), но менее эффективен для динамических или объектно-ориентированных приложений. Перспективы включают интеграцию с ООП, автоматизацию и образовательную роль, но его значение снижается в новых областях, таких как микросервисы или ИИ. Учебник (стр. 4–5, 229) подчеркивает его важность для проектирования и документирования.





